\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\fontencoding{T1}
\usepackage{amsmath,amssymb,graphicx,color,enumerate,hyperref}
\usepackage{minted}
\usepackage{todonotes}
\title{GRACe tutorial}
\author{}
\date{\today}

% AG:
\newminted{haskell}{fontsize=\normalsize,xleftmargin=2mm,mathescape,linenos}
\newcommand{\haskell}[1]{\mintinline{haskell}|#1|}
\DefineShortVerb{\|}

\begin{document}
\maketitle
%TODO:
% * How to define a library to send to the visual editor?
%   (add once the connection to and status of the viseditor is clearer )
% * Discuss actions and params
% * Say something about how to run programs?

\noindent
In this tutorial we introduce the GRACe DSL and demonstrate how to define GRACe
components and write programs using those components. The GRACe DSL is divided
into two Haskell modules: |GCM| and |CP|. The |GCM| module allows the user to
define GRACeFUL Concept Map components and connect them to each other. The |CP|
module contains primitives for constructing constraint programs, which describe
the behaviour of an individual component.


\section{GCM components and ports}

We model a |GCM| component by defining the ports it exposes. A |Port| represents
a value that can be constrained. Two ports can be linked together to describe
the connection between their respective components. Information contained in a
component that we want to access in other parts of our model can be exposed
through the component's ports. For instance, consider the following definition
of a component that models a fixed amount of rain falling from the sky.  It is
parametrised on the amount of rain and has a port to expose that value to other
components.
\begin{haskellcode}
rain :: Float -> GCM (Port Float)
rain amount = do
  p <- createPort
  set p amount
  return p
\end{haskellcode}
The GRACe language is monadic which here means that we can use the
|do|\footnote{\url{https://en.wikibooks.org/wiki/Haskell/do_notation}}
notation to define our component in a manner which resembles a
sequential program. The |createPort| command creates a new port, and
the |set| command constrains the value of the port |p| to be equal to
|amount|.


\section{CP}

The |CP| module of GRACe supports reasoning about integer and floating-point
arithmetic, Boolean expressions, and arrays. Computations in |CP| can be
embedded in |GCM| using the |component| primitive. In this way we can embed
constraints on a component's ports in the definition of the component.

Consider a |GCM| component representing a pump parametrised over the maximum
flow through the pump:
\begin{haskellcode}
pump :: Float -> GCM (Port Float, Port Float)
pump maxCap = do
  inPort  <- createPort
  outPort <- createPort
  component $ do             -- This is in CP
    inflow  <- value inPort
    outflow <- value outPort
    assert $ inflow === outflow                -- no leakage
    assert $ inflow `inRange` (0, lit maxCap)  -- no back-flow, limited capacity
  return (inPort, outPort)
\end{haskellcode}

We define ports for the inflow and outflow of the pump, assert that their values
must be equal, and that their values cannot exceed the pump's maximum capacity.
The |value| command reads the value from a port, and the |assert| command allows
us to express constraints. Note that we need to use |lit| to lift |maxCap|,
which is a value in the host language Haskell, into the embedded language GRACe.

Finally we show a more complicated component, a water runoff area with an
inflow, an outlet to which we may connect e.g. a pump, and an overflow. Here we
can see some different constraints that are supported by the |CP| module.
\begin{haskellcode}
runoffArea :: Float -> GCM (Port Float, Port Float, Port Float)
runoffArea cap = do
  inflow   <- createPort
  outlet   <- createPort
  overflow <- createPort
  component $ do
    currentStored <- createVariable
    inf <- value inflow
    out <- value outlet
    ovf <- value overflow
    sto <- value currentStored
    assert $ sto === inf - out - ovf
    assert $ sto `inRange` (0, lit cap)
    assert $ (ovf .> 0) ==> (sto === lit cap)
    assert $ ovf .>= 0
  return (inflow, outlet, overflow)
\end{haskellcode}

\section{GRACe programs}

In a GRACe program we define instances of available components and define their
connections by linking their ports. As an example, we show a small GRACe program
using the components defined earlier. We can think of it as modelling a rain
runoff area, like a town square, which has been provided with a pump to
alleviate possible flooding issues.
\begin{haskellcode}
example :: GCM ()
example = do
  (inflowP, outflowP) <- pump 3
  (inflowS, outletS, overflowS) <- runoffArea 5
  rainflow <- rain 10

  link inflowP outletS
  link inflowS rainflow

  output overflowS "Overflow"
\end{haskellcode}
The |link| command links two ports together and asserts that their values are
equal. The |output| command lets us inspect the resulting value at a |Port|
after all constraints have been solved.


\section{Component library}
We can build a component library from the components we have defined.
This library can be sent to the visual editor front-end where the user can then
build a GCM by connecting the ports of component instances and giving values to
their parameters. The library contains the components along with annotations of
information to display in the visual editor and type annotations to preserve
information about the components' types.

Here you can see the library |exampleLib| which contains the three components
defined above, defined using the |Library| type.
\begin{haskellcode}
exampleLib :: Library
exampleLib = Library "crud"
    [ item "rain" "Rain" "path_to_images/rain.png" $
        rain ::: "amount" #
          tFloat .-> tGCM          (tPort $ "rainfall" # tFloat)
    , item "pump" "Pump" "path_to_images/pump.png" $
        pump ::: "capacity" #
          tFloat .-> tGCM (tPair   (tPort $ "inflow"   # tFloat)
                                   (tPort $ "outflow"  # tFloat))
    , item "runoff area" "Runoff" "path_to_images/runOffArea.png" $
        runoffArea ::: "storage capacity" #
          tFloat .-> tGCM (tTuple3 (tPort $ "inflow"   # tFloat)
                                   (tPort $ "outlet"   # tFloat)
                                   (tPort $ "overflow" # tFloat))
    ]
\end{haskellcode}
A |Library| has a string representing its ID, in this case |"crud"|, followed by
a list of items. An |Item| contains a component with a type annotation,
along with strings representing its ID, a comment to display when hovering over
an instance of the corresponding component in the visual editor, and the path to
an image that can be used to visually represent the component.

A type annotation for a component looks like the component's type signature
but with slightly different syntax, namely |:::| instead of |::|, |.->| instead
of |->|, and a |t| in front of the original type names (i.e. |tPort| to
represent |Port|). Note also that tuples need special handling: 2-tuples are
annotated by |tPair| and 3-tuples by |tTuple3|. Type annotations can also have
tags, where a string ID is tagged to a type annotation with a |#| symbol. For
instance, in line 7 above, the string ID |"capacity"| is tagged to the following
|tFloat| annotation, implying that the |Float| in question has the ID
|capacity|. These type annotations are used to keep track of type information
when the library components are sent back and forth via JSON.

\section{Example: Vegetable Oil Production}

The example in the previous section is rather small. We continue in this section
with the explanation of a slightly larger example. The example we show is a
simple optimization problem.

Let us assume we have an amount of farmland and three available crops, and would
like to know how much of each crop to grow on the land to maximize our vegetable
oil production. Each crop has parameters that state the yield of the crop, in
tonnes, from one hectare of growing land, the amount of water required per
hectare to grow the crop, and how much oil can be produced from one tonne of the
crop.
%
This example has been chosen because it is easy to imagine different
stakeholders having different interests: one may strive to maximise
production, another may aim to minimize water use, etc.


To model this problem in GRACe we define a component for each crop, using these
parameters, with ports expressing the number of hectares, the oil yield, and the
water consumption.
\begin{haskellcode}
-- | GCM component for a single crop.
--
-- The component is parametrised on the crop's parameters and computes the
-- oil yield (in l) and water consumption (in Ml), given that we grow
-- so-and-so many ha of this crop.
crop :: CropParams -> GCM (Port Area, Port Water, Port Oil)
crop (y,w,o) = do
  -- Area (in ha) used to grow crop.
  areaPort  <- createPort

  -- Amount of water used by crop.
  waterPort <- createPort
  -- Amount of oil produced from crop.
  oilPort   <- createPort

  -- Constrain the values at the ports.
  component $ do
    areaValue  <- value areaPort
    oilValue   <- value oilPort
    waterValue <- value waterPort

    -- Calculate values from data.
    assert $ oilValue   === lit y * lit o * areaValue
    assert $ waterValue === lit w * areaValue

  return (areaPort, waterPort, oilPort)
\end{haskellcode}
We also define components for the available farmland and water supply, and the
oil production, which all have ports to link to each crop. We parametrised them
on the number of different crops for the sake of generality.
\begin{haskellcode}
-- | GCM component for farmland.
--
-- The component is parametrised on the available amount of land (in ha)
-- and the number of different crops available to grow, and has ports
-- describing how the land is divided between the crops.
farm :: Area -> Int -> GCM [Port Area]
farm land numCrops = do
  -- Create a port for each crop.
  areaPorts <- mapM (\_ -> createPort) (take numCrops (repeat 0))
  component $ do
    areaVals <- sequence [value ap | ap <- areaPorts]
    --  The total area of crops is non-negative and is bounded by the available
    --  farmland. Each crop area is also non-negative.
    assert $ sum areaVals `inRange` (0, lit land)
    mapM_ (\x -> assert $ 0 .<= x) areaVals
  return areaPorts

-- | GCM component for water usage.
--
-- The component is parametrised on the available amount of water (in Ml)
-- and the number of different crops available to grow, and has ports
-- describing how the water is divided between the crops.
reservoir :: Water -> Int -> GCM [Port Water]
reservoir waterSource numCrops = do
  -- Create a port for each crop.
  waterPorts <- mapM (\_ -> createPort) (take numCrops (repeat 0))
  component $ do
    waterVals <- sequence [value wp | wp <- waterPorts]
    -- The total amount of water used is non-negative and is bounded by the
    -- available water reservoir. The amount for each crop is also non-negative.
    assert $ sum waterVals `inRange` (0, lit waterSource)
    mapM_ (\x -> assert $ 0 .<= x) waterVals
  return waterPorts

-- | GCM component for oil production.
--
-- The component is parametrised on the number of different crops available
-- to grow, and has a list of ports describing how much oil is produced by
-- each crop as well as a port containing the total amount of oil produced.
oilProduction :: Int -> GCM ([Port Oil], Port Oil)
oilProduction numCrops = do
  -- Create a port for each crop.
  oilCrops <- mapM (\_ -> createPort) (take numCrops (repeat 0))
  oilOut <- createPort
  component $ do
    oilProduced <- value oilOut
    oilSources <- mapM value oilCrops
    -- The total amount of oil is the sum of the amounts from each crop.
    assert $ oilProduced === sum oilSources
  return (oilCrops, oilOut)
\end{haskellcode}
Our goal is to maximize the amount of oil produced, and we define the helper
function |maximize| to help us express this:
\begin{minted}{haskell}
maximize :: Port Int -> GCM ()
maximize p = do
  g <- createGoal
  link p g
\end{minted}
The command |createGoal| instantiates a |GCM| goal, which the constraint
solver attempts to maximize. Using this helper function we can simply write:
\begin{minted}{haskell}
maximize p
\end{minted}
to state that we would like to maximize the value at port |p|. Conversely, if
our goal is to minimize a certain value we can define a similar helper function
|minimize|:
\begin{minted}{haskell}
minimize :: Port Int -> GCM ()
minimize p = do
  g <- createGoal
  linkBy (fun negate) p g
\end{minted}
Where the |link| command asserts that two values must be equal, the |linkBy|
command takes a function as a parameter to express a more complex constraint on
the values.

The full code for the vegetable oil example can be seen in Appendix~\ref{oilcode}.


\appendix

\section{Vegetable Oil Production - Full code}\label{oilcode}

\inputminted[linenos]{haskell}{examples/OilCrops.hs}

\end{document}
