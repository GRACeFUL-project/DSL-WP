\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\fontencoding{T1}
\usepackage{amsmath,amssymb,graphicx,color,enumerate,hyperref}
\usepackage{minted}
\usepackage{todonotes}
\title{GRACe tutorial}
\author{}
\date{\today}

\begin{document}
\maketitle
%TODO:
% * How to define a library to send to the visual editor?
%   (add once the connection to and status of the viseditor is clearer )
% * Discuss actions and params
% * Say something about how to run programs?

In this tutorial we introduce the GRACe DSL and demonstrate how to define
GRACe components and write programs using those components.

GRACe is divided into two modules, GCM and CP. The GCM module allows the user
to define GRACeFUL Concept Map components and describe how they are connected.
The CP module contains primitives for constructing constraint programs which
describe the behavior of an individual component.

\section{GCM components and ports}
We model a \texttt{GCM} component by defining the ports it exposes.

A \texttt{Port} contains a value that can be constrained.
Two ports can be linked together to describe the connection between their
respective components.
Information contained in a component that we want to access in other parts
of our program can be exposed through the component's ports.

For instance, consider the following definition of a component which models
a fixed amount of rain falling from the sky.
It is parametrized on the amount of rain and has a port to expose that value
to another component.
\begin{minted}[linenos]{haskell}
rain :: Float -> GCM (Port Float)
rain amount = do
  p <- createPort
  set p amount
  return p
\end{minted}
Since the GRACe language is monadic we can use \textbf{do} notation and define our
component in a sequential manner.

The \texttt{createPort} command creates a new port, and the \texttt{set} command
constrains the value of the port \texttt{p} to be equal to \texttt{amount}.

\section{CP}
The \texttt{CP} module of GRACe supports reasoning about integer and floating-point arithmetic,
boolean expressions, and arrays.

Computations in \texttt{CP} can be embedded in \texttt{GCM} using the
\texttt{component} primitive. In this way we can embed constraints on a
component's ports in the definition of the component.

Consider a \texttt{GCM} component representing a pump
parametrised over the maximum flow through the pump:
%
\begin{minted}[linenos]{haskell}
pump :: Float -> GCM (Port Float, Port Float)
pump maxCap = do
  inPort  <- createPort
  outPort <- createPort
  component $ do             -- This is in CP
    inflow  <- value inPort
    outflow <- value outPort
    assert $  inflow === outflow
    assert $  inflow `inRange` (0, lit maxCap)
  return (inPort, outPort)
\end{minted}
We define ports for the inflow and outflow, assert that their values must
be equal, and that their values cannot exceed the pump's maximum capacity.

The \texttt{value} command reads the value from a port,
and the \texttt{assert} command allows us to express constraints.

Note that we need to use \texttt{lit} to lift \texttt{maxCap}, which
is a value in the host language Haskell, into the embedded language
GRACe.

Finally we show a more complicated component, a water runoff area with
an \texttt{inflow}, an \texttt{outlet} to which we may connect e.g. a pump,
and an \texttt{overflow}.

Here we can see various different kinds of constraints
that are supported by the \texttt{CP} module.
\begin{minted}[linenos]{haskell}
runoffArea :: Float -> GCM (Port Float, Port Float, Port Float)
runoffArea cap = do
  inflow   <- createPort
  outlet   <- createPort
  overflow <- createPort
  component $ do
    currentStored <- createVariable
    inf <- value inflow
    out <- value outlet
    ovf <- value overflow
    sto <- value currentStored
    assert $ sto === inf - out - ovf
    assert $ sto `inRange` (0, lit cap)
    assert $ (ovf .> 0) ==> (sto === lit cap)
    assert $ ovf .>= 0
  return (inflow, outlet, overflow)
\end{minted}

\section{GRACe programs}
In a GRACe program we define instances of available components and
define their connections by linking their ports.

As an example, here is a small GRACe program using the components defined
earlier. We can think of it as modeling a rain runoff area, like a
town square, which has been provided with a pump to alleviate possible
flooding issues.
%
\begin{minted}[linenos]{haskell}
example :: GCM ()
example = do
  (inflowP, outflowP) <- pump 3
  (inflowS, outletS, overflowS) <- runoffArea 5
  rainflow <- rain 10

  link inflowP outletS
  link inflowS rainflow

  output overflowS "Overflow"
\end{minted}
The \texttt{link} command links two ports together and asserts that their values
must be equal.

The \texttt{output} command lets us inspect the resulting value at a \texttt{Port}
after all constraints have been solved.

\section{Example: Vegetable Oil Production}
As an example we consider a simple optimization problem.

We have a set amount of farmland and three available crops, and would like to
know much of each crop to grow on the land to maximize our vegetable oil
production.

Each crop has parameters that state the yield of the crop, in tons, from one hectare of
growing land, the amount of water required per hectare to grow the crop, and how
much oil can be produced from one ton of the crop.

We define a component for each crop, using these parameters, with ports
expressing the number of hectares, the oil yield, and the water consumption.

\begin{minted}[linenos]{haskell}
-- | GCM component for a single crop.
--
-- The component is parametrized on the crop's parameters and computes the
-- oil yield (in l) and water consumption (in Ml), given that we grow
-- so-and-so many ha of this crop.
crop :: CropParams -> GCM (Port Area, Port Water, Port Oil)
crop (y,w,o) = do
  -- Area (in ha) used to grow crop.
  areaPort  <- createPort

  -- Amount of water used by crop.
  waterPort <- createPort
  -- Amount of oil produced from crop.
  oilPort   <- createPort

  -- Constrain the values at the ports.
  component $ do
    areaValue  <- value areaPort
    oilValue   <- value oilPort
    waterValue <- value waterPort

    -- Calculate values from data.
    assert $ oilValue   === lit y * lit o * areaValue
    assert $ waterValue === lit w * areaValue

  return (areaPort, waterPort, oilPort)
\end{minted}

We also define components for the available farmland and water supply, and the
oil production, which all have ports to link to each crop. We parametrize them
on the number of different crops for the sake of generality.

\begin{minted}[linenos]{haskell}
-- | GCM component for farmland.
--
-- The component is parametrized on the available amount of land (in ha)
-- and the number of different crops available to grow, and has ports
-- describing how the land is divided between the crops.
farm :: Area -> Int -> GCM [Port Area]
farm land numCrops = do
  -- Create a port for each crop.
  areaPorts <- mapM (\_ -> createPort) (take numCrops (repeat 0))
  component $ do
    areaVals <- sequence [value ap | ap <- areaPorts]
    --  The total area of crops is non-negative and is bounded by the available
    --  farmland. Each crop area is also non-negative.
    assert $ sum areaVals `inRange` (0, lit land)
    mapM_ (\x -> assert $ 0 .<= x) areaVals
  return areaPorts

-- | GCM component for water usage.
--
-- The component is parametrized on the available amount of water (in Ml)
-- and the number of different crops available to grow, and has ports
-- describing how the water is divided between the crops.
reservoir :: Water -> Int -> GCM [Port Water]
reservoir waterSource numCrops = do
  -- Create a port for each crop.
  waterPorts <- mapM (\_ -> createPort) (take numCrops (repeat 0))
  component $ do
    waterVals <- sequence [value wp | wp <- waterPorts]
    -- The total amount of water used is non-negative and is bounded by the
    -- available water reservoir. The amount for each crop is also non-negative.
    assert $ sum waterVals `inRange` (0, lit waterSource)
    mapM_ (\x -> assert $ 0 .<= x) waterVals
  return waterPorts

-- | GCM component for oil production.
--
-- The component is parametrized on the number of different crops available
-- to grow, and has a list of ports describing how much oil is produced by
-- each crop as well as a port containing the total amount of oil produced.
oilProduction :: Int -> GCM ([Port Oil], Port Oil)
oilProduction numCrops = do
  -- Create a port for each crop.
  oilCrops <- mapM (\_ -> createPort) (take numCrops (repeat 0))
  oilOut <- createPort
  component $ do
    oilProduced <- value oilOut
    oilSources <- mapM value oilCrops
    -- The total amount of oil is the sum of the amounts from each crop.
    assert $ oilProduced === sum oilSources
  return (oilCrops, oilOut)
\end{minted}

Our goal is to maximize the amount of oil produced, and we define the helper
function \texttt{maximize} to help us express this:
\begin{minted}{haskell}
maximize :: Port Int -> GCM ()
maximize p = do
  g <- createGoal
  link p g
\end{minted}

The command \texttt{createGoal} instantiates a GCM goal, which the constraint
solver will attempt to maximize. Using this helper function we can simply write
\begin{minted}{haskell}
maximize p
\end{minted}
to state that we would like to maximize the value at port \texttt{p}.

Conversely, if our goal is to minimize a certain value we can define a similar
helper function \texttt{minimize}
\begin{minted}{haskell}
minimize :: Port Int -> GCM ()
	minimize p = do
	  g <- createGoal
	  linkBy (fun negate) p g
\end{minted}

While the \texttt{link} command asserts that two values must be equal, the
\texttt{linkby} command takes a function as a parameter to express a more
complex constraint on the values.

The full code for the vegetable oil example can be seen in Appendix~\ref{oilcode}
\appendix
\section{Vegetable Oil Production - Full code}\label{oilcode}
\inputminted[linenos]{haskell}{examples/OilCrops.hs}
\end{document}
