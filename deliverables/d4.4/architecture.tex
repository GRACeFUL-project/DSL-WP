The software stack of the GRACeFUL project consists of
%
a visual editor frontend,
%
a network layer,
%
a GCM component library,
%
a DSL called GRACe,
%
a middleware called haskelzinc, and
%
a choice of external constraint solver.
%
In this section we briefly describe the different layers and how testing and
verification is performed on each layer.

\subsubsection*{Visual Editor}

The top layer of the software stack is the visual editor.
%
It provides a graphical user interface where the user can build GCMs
as a graphical map from available components.
%
The visual editor is implemented in the programming language JavaScript, using
the Data Driven Documents library (D3.js).
%

The code for the visual editor can be found in the
\href{https://github.com/GRACeFUL-project}{GRACeFUL-project} GitHub
repository
\href{https://github.com/GRACeFUL-project/GRACeFULEditor}{GRACeFULEditor}.

\todo{Is there anything to say about testing here? Maybe refer to user testing
  related deliverable/stuff}
\todo{AG: mention the evaluation with stakeholders here?}

The visual editor is described in deliverabe D3.3 including how it can be
accessed\footnote{\url{http://vocol.iais.fraunhofer.de/graceful-rat/static/}},
how it can be used, and more details on how it is implemented.

\todo{Refer to section on using type systems for testing/verification (and mention our
typed libraries as an example in that section.)}
\subsubsection*{GRACe}

GRACe is a domain specific language embedded in Haskell. It is used to express
GRACeFUL concept maps (GCMs) and GCM library components. GRACe programs
representing GCMs are compiled to haskelzinc constraint programs, and the
resulting solutions are passed back to GRACe. The DSL is described in deliverable
D4.2.

\subsubsection*{GCM component libraries}

The visual editor allows users to create a GRACeFUL Concept Map with components
of a chosen library. Components are written in GRACe and are grouped in a
library, for example a library with CRUD components. The visual editor can query
the components available in a library using its identifier. A JSON
representation of the components are sent to the visual editor.

The following code shows an example CRUD library, where |rain| and |pump| are
|GCM| components:
\begin{haskellcode}
library :: Library
library = Library "crud"
    [ item "rain" $
        rain ::: "amount" #
          tFloat .-> tGCM          (tPort $ "rainfall" # tFloat)
    , item "pump" $
        pump ::: "capacity" #
          tFloat .-> tGCM (tPair   (tPort $ "inflow"   # tFloat)
                                   (tPort $ "outflow"  # tFloat))
    ]
\end{haskellcode}
The example library makes use of Typed Values, which are explained in
Section~\ref{sec:verification}.

\todo{Say something about session check stuff.}
\subsubsection*{Communication with visual editor}

The GRACeServer provides a RESTful API and uses JSON\footnote{JavaScript Object
Notation} as the exchange format. The server offers the following webservices:
\begin{quote}
\begin{description}
\item [\haskell{libraries}] returns a list with the available component libraries
\item [\haskell{library (id)}] has a library identifier parameter and returns 
  a list with a description (in JSON) of the all library components
\item [\haskell{submit (gcm)}] takes a GRACeFUL Concept Map description as
  argument, which is translated to a GRACe DSL program, and returns the result 
  of the constraint solver
\end{description}
\end{quote}
The visual editor, developed in work package 3, communicates with the GRACeServer
by making service calls. The GRACeServer is available as the \texttt{RestAPI} 
executable in the \href{https://github.com/GRACeFUL-project/GRACe}{GRACe} repository.

\todo{Refer to GCMP section}
\subsubsection*{Haskelzinc}

Haskelzinc is a Haskell interface to the MiniZinc constraint
programming language.
%
It provides a Haskell DSL for building MiniZinc model representations and a parser that returns a representation of the solutions obtained
by running the MiniZinc model.

The latest version of haskelzinc (currently 0.3) is available from
\url{https://hackage.haskell.org/package/haskelzinc}.

\todo{Refer to section on inductive testing/backend comparison/ satisfiability testing}
