\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[unicode=true]{hyperref}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Patrik Jansson et al.},
            pdftitle={GRACeFUL D4.4: Testing and verification framework},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

%% Cezar
\usepackage[margin=1.60in]{geometry}
\usepackage[verbose]{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{rotating}
\usepackage{lscape}
\usepackage{float}
\usepackage{geometry}
\usepackage{framed}
\usepackage{xspace}
\usepackage{acronym}
\usepackage[square,numbers]{natbib}

%% Max
\usepackage{minted}
\usepackage{todonotes}

%% Alex
\newminted{haskell}{fontsize=\normalsize,xleftmargin=2mm,mathescape,linenos}
\newcommand{\haskell}[1]{\mintinline{haskell}|#1|}
\DefineShortVerb{\|}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\definecolor{GRACeFULblue}{rgb}{0.20,0.60,0.86}

\newcommand{\grace}{GRACeFUL\xspace}
\acrodef{GCM}{\grace Concept Map}
\acrodef{GMB}{Group Model Building}
\acrodef{DSL}{Domain Specific Language}
\acrodef{CFP}{Constraint Functional Program}
\acrodef{RAT}{Rapid Assessment Tool}
\acrodef{CRUD}{Climate Resilient Urban Design}
\acrodef{CLD}{Causal Loop Diagram}
\acrodef{JSON}{JavaScript Object Notation}
\acrodef{CP}{Constraint Program}
\hyphenation{GRACeFUL}

\author{}
\date{}

\begin{document}

\begin{center}
\includegraphics[width=5cm]{../coverpage/GRACeFULlogo.png}

\textcolor{GRACeFULblue}{Global systems Rapid Assessment tools\\
through Constraint FUnctional Languages}

\vspace{1cm}

FETPROACT-1-2014 Grant Nº 640954

\end{center}

\begin{framed}
\begin{center}
\Large
D4.4: Testing and verification framework\\[1ex]

\large
D4.4 Testing and verification framework for RATs\\
with applications to the CRUD case study\\[1ex]

\end{center}
\end{framed}

\vspace{1cm}

\noindent
\begin{tabular}{@{}ll@{}}
  Lead Participant:       & Chalmers (WP leader: P. Jansson)
\\Dissemination Level:    & PU
\\Document Version:       & Draft
\\Date of Submission:     & 2018-0?-??
\\Due Date of Delivery:   & 2018-01-31
\end{tabular}

Authors: Maximilian Algehed, Sólrún Einarsdóttir, Alex Gerdes, and
Patrik Jansson.

\begin{abstract}

This fourth deliverable (D4.4) of work package 4 presents a framework for
testing and verifying communicating systems.
%
The work leading up to this deliverable is within Task 4.5 ``Build a
testing and verification framework for RATs'' and the full source code
of the implementation is available on GitHub.

\end{abstract}
\newpage

\section{Introduction}
\label{sec:intro}

\input{intro}


\section{Verification through types and tests}

Rapid Assessment Tools are used to evaluate plans for problems in Global System
Sciences, such as Climate Resilient Urban Design. The evaluation output that is
our produced by the tools, which we have developed in the GRACeFUL project,
should be reliable. This implies that the software that we have developed should
ideally be free of errors. It is well known that this is an utopia and not
realistic. We can, however, do our best to keep the number of errors as low as
possible. In this section we describe the two approaches to software
verification that we have used in this project: types and property-based
testing. 

\subsection{Strong types}

Types are not only used in computer science to generate code, but also as a
\emph{specification} of parts of a program, such as functions and expressions. A
type checker, normally part of a compiler, checks if the declared types match
with the expected ones. A programmer can use a type checker to (semi-)formally
verify the given specification, in the form of type declarations and
annotations. In this sense, type systems can be regarded as the most used
formal verification. It is of course a light-weight kind of formal verification,
but nevertheless very useful. 

We have used types extensively in the GRACeFUL project, in particular in our
domain specific language GRACe, the GRACeServer, and in Haskelzinc, the
interface to the constraint programming layer. Our DSL for GRACeFUL concept maps
is embedded in Haskell, which is a strongly typed functional programming
language. Using Haskell's type system we can prevent a DSL user of making
mistakes.

An end user of the GRACeFUL tool chain is most likely not programming directly
in Haskell using our GRACe DSL, but using the Visual Editor from Work Package 2
instead. This poses a problem since the communication the Visual Editor goes via
an untyped channel. An additional problem is that we want to group GCM
components, which we mentioned in Section~\ref{sec:intro}, in a library, which
is a challenge if you want to do this in a type safe manner. GCM components can
have many different types, which makes it hard to collect them in a data type,
such as a list.

We have addressed the above issues with \emph{Typed Values}, which are related
to the |Typeable| and |Dynamic| Haskell libraries~\cite{DataDynamic}. We give a
short description of Typed Values, leaving out many implementation details. The
key idea behind Typed Values is to combine a value with its \emph{type
representation}. A type representation can be encoded as follows in Haskell:
\begin{haskellcode}
data Type t where
  Int   :: Type Int
  Bool  :: Type Bool
  Tag   :: String -> Type t -> Type t
  List  :: Type t -> Type [t]
  (:->) :: Type a -> Type b -> Type (a -> b)
\end{haskellcode}
The above GADT 
\begin{haskellcode}
data a :~: b where
  Refl :: a :~: a

(?=) :: Type a -> Type b -> Maybe (a :~: b)
Int          ?= Int        = return Refl
Bool         ?= Bool       = return Refl
Tag t        ?= Tag t'     = t ?= t'
(List t)     ?= (List t')  = do
  Refl <- t ?= t'
  return Refl
(t0 :-> t1)  ?= (t0' :-> t1') = do
  Refl <- t0 ?= t0'
  Refl <- t1 ?= t1'
  return Refl
\end{haskellcode}

\begin{haskellcode}
data TypedValue where
  (:::) :: a -> Type a -> TypedValue
\end{haskellcode}


\subsection{Property-based testing}
A traditional way of testing software is using so-called unit tests. An unit
test case specifies some input data along with the expected output. We use these
test cases to assure that the software is behaving as expected. For real-life
sized software projects, however, there are many test cases needed to get a
decent test coverage, which makes maintenance more difficult. Moreover, it is
hard to think of all the corner cases that may be present in the software.

An alternative approach is \emph{property-based testing}, which verifies
software against particular properties that the software should have. A property
can be regarded as an abstraction over many unit tests. These properties should
hold for \emph{all} input and, as a consequence, we can \emph{generate} input
data. Property-based testing uses generated random input data to test such
properties. Properties are powerful: a good property gives a strong
specification for a large set of test data. 

QuickCheck~\cite{QuickCheck} is a well known implementation of property-based
testing, and is available in many programming languages.  QuickCheck verifies
properties by generating a large number of random test cases, and reports test
cases for which the property fails. 

For example, a property of the |reverse| function from the Haskell standard
library (the |Prelude|) is that if reverse a list twice, we end up with the same
list. This can be expressed in Haskell QuickCheck as follows:
\begin{haskellcode}
propTwice :: [Int] -> Bool
propTwice = \ xs -> xs == reverse (reverse xs)
\end{haskellcode}
We can validate such a property by calling |quickCheck|:
\begin{minted}{shell}
> quickCheck propTwice
+++ OK, passed 100 tests.
\end{minted}
The above evaluation shows that the |reverse| function most likely adheres to
the |propTwice| property. When QuickCheck finds a failing test case, a so-called
counterexample, it shrinks the failing test case automatically, by searching for
similar, but smaller test cases that fail as well. The result of shrinking is a
minimal failing test case simplifying the debugging process. 


\section{Testing Communicating Systems}
%
SessionCheck \cite{SessionCheck} is a tool developed in WP4 to test distributed systems like
the GRACeFUL editor.
%
The tool is focused on the communication protocols used between the components.
%
In the case of the GRACeFUL editor the protocol would be the REST API described in deliverable D4.3. %\cite{D4.3}
%
But, as the tool can do more than that, we here give a mini-tutorial
of how to use SessionCheck in general.

Typical testing of distributed systems is done by maintaining a database consisting of hundreds
or thousands of test-cases, each specifying the behaviour of one party in the protocol with
respect to a specific exchange of messages, a trace.
%
This approach is not ideal, as each test case is an artifact on its own which needs to be kept
in sync with the rest of the software.
%
SessionCheck relieves developers of the duty of maintaining hundreds of software
artifacts, replacing them with only three: the client, the server, and the SessionCheck specification.

To see the SessionCheck specfication language in action, consider a
simple protocol between a server and a client which requires the
client to transmit two positive integers and receive back from the
server their sum.
%
In SessionCheck, this specification would be written as follows:
%

\begin{minted}{Haskell}
  protocol :: Spec Int Int
  protocol = do
    a <- send posInt
    b <- send posInt
    get (is (a + b))
\end{minted}

%
SessionCheck specifications are written from the point of view of a particular party, in this case the client.
%
We may as well have written the same specification from the point of view of the server,
in which case it would look like this:
%

\begin{minted}{Haskell}
  protocol' :: Spec Int Int
  protocol' = do
    a <- get posInt
    b <- get posInt
    send (is (a + b))
  \end{minted}

%
It is no coincidence that the two specifications are very similar, and SessionCheck can work equally well with
both, as we will see shortly.

\begin{figure}[tbp]
  \begin{minted}{Haskell}
    data Spec t a   -- SessionCheck spec. for channel type t

    send    ::  a :< t =>  Predicate a ->       Spec t a
    get     ::  a :< t =>  Predicate a ->       Spec t a
    stop    ::                                  Spec t a
    fail    ::  String ->                       Spec t a
    return  ::  a ->                            Spec t a
    (>>=)   ::  Spec t a -> (a -> Spec t b) ->  Spec t b

    -- Derived combinators
    choose  :: (Eq a, a :< t) =>  [a] ->       Spec t a
    branch  :: (Eq a, a :< t) =>  [a] ->       Spec t a
  \end{minted}
  \caption{\label{fig:SessionCheck:language} The SessionCheck language}
\end{figure}
%
The SessionCheck specification language is a domain specific language embedded in the Haskell \cite{Haskell}
programming language.
%
Being an embedded language means that the language primitives in SessionCheck are
implemented as Haskell data types and functions.
%
The language primitives in SessionCheck can be seen in Figure \ref{fig:SessionCheck:language}.
%
The type argument \mintinline{Haskell}{t} in the type \mintinline{Haskell}{Spec t a} denotes the type of messages
being delivered on the channel on which the system under test is communicating
with SessionCheck.
%
The \mintinline{Haskell}{send} and \mintinline{Haskell}{get} primitives represent obligations for the respective party to send a message
which is compliant with the given \mintinline{Haskell}{Predicate}, more on this soon.
%
The type constraint \mintinline{Haskell}{a :< t} (for \mintinline{Haskell}{send} and
\mintinline{Haskell}{get}) denotes a subtyping relation between \mintinline{Haskell}{a} and
\mintinline{Haskell}{t}.
%
That is, any value of type \mintinline{Haskell}{a} can be transformed into value of type \mintinline{Haskell}{t}, and it may be
possible to transform a value of type \mintinline{Haskell}{t} into value of type \mintinline{Haskell}{a}.
%

Included in the interface are also the \mintinline{Haskell}{stop} and \mintinline{Haskell}{fail} functions.
%
The \mintinline{Haskell}{stop} primitive specifies that the protocol session is successfully terminated.
%
The behaviour of \mintinline{Haskell}{stop} is specified by the equation \mintinline{Haskell}{stop >>= f = stop}.
%
Unlike \mintinline{Haskell}{send}, \mintinline{Haskell}{get}, and \mintinline{Haskell}{stop},
the \mintinline{Haskell}{fail} primitive does not directly correspond to an action in the protocol.
%
Rather it allows the user to specify conditions, for when the system being tested by SessionCheck fails,
which are not directly coupled to constraints on messages.
%
The \mintinline{Haskell}{choose} and \mintinline{Haskell}{branch} primitives are not actually
primitive operations, rather they are derived from (implemented using)
the rest of the interface.
%
The specification \mintinline{Haskell}{choose xs} reads ``send one of the values in \mintinline{Haskell}{xs}'',
while \mintinline{Haskell}{branch xs} reads ``get one
of the values in \mintinline{Haskell}{xs}''.

The primitives explained so far do not permit small specifications
(like \mintinline{Haskell}{send anyInt} and \mintinline{Haskell}{get anyBool}) to be composed to
form more complex specifications.
%
For this purpose SessionCheck also supports the standard \mintinline{Haskell}{Monad} interface~\cite{WadlerMonad}, which contains the
two primitive operations \mintinline{Haskell}{return} and \mintinline{Haskell}{(>>=)} (pronounced ``bind'').
%
The bind operator allows specifications to be composed by taking a specification, \mintinline{Haskell}{s}, and a function which
creates a specification from a value, \mintinline{Haskell}{f}, and composing them to form the specification \mintinline{Haskell}{s >>= f} which means
``first the protocol behaves like \mintinline{Haskell}{s}, then whatever value is produced at the end of \mintinline{Haskell}{s} is fed to \mintinline{Haskell}{f} to produce
a new specification to follow''.
%
As an example, consider the case where \mintinline{Haskell}{s = send anyInt} and \mintinline{Haskell}{f x = send (greaterThan x)}, here \mintinline{Haskell}{s >>= f} is
a specification which first requires the end-point to send an \mintinline{Haskell}{Int} and then to send another \mintinline{Haskell}{Int} which is greater
than the first one.
%
The \mintinline{Haskell}{do ...} notation in the above examples is syntactic sugar for successive uses of \mintinline{Haskell}{(>>=)} and lambda abstraction
\mintinline{Haskell}{\ x -> e}, where the expression \mintinline{Haskell}{\ x -> e} denotes a function where the variable \mintinline{Haskell}{x} is used to bind the input of
the function in the (output) expression \mintinline{Haskell}{e}.
%
When written using explicit \mintinline{Haskell}{(>>=)} the specification of \mintinline{Haskell}{protocol} could look like this:
%
\begin{minted}{haskell}
protocol :: Spec Int Int
protocol = send posInt >>= \ a -> send posInt >>= \ b -> get (is (a + b))
\end{minted}


%
Supporting the generic \mintinline{Haskell}{Monad} interface means that we get several useful combinators ``for free'', like
\mintinline{Haskell}{(>>) :: Spec t a -> Spec t b -> Spec t b} which sequences two independent specifications, and
\mintinline{Haskell}{forever :: Spec t a -> Spec t b} which repeats a specification indefinitely.
%
Finally, the \mintinline{Haskell}{return} function simply wraps a value in a specification.
%
It represents no obligation on either part of the communication protocol, but rather is part of the standard
monad interface.
%

% \begin{figure}
%   \begin{minted}{haskell}
%     echo = do
%       s <- send anyString
%       get (is s)
%   \end{minted}
%   \caption{\label{fig:SessionCheck:echo} The \mintinline{Haskell}{echo} protocol}
% \end{figure}
% %
As a third example of a SessionCheck specification we can take the \mintinline{Haskell}{echo} protocol:
%
\begin{minted}{haskell}
  echo = do
    s <- send anyString
    get (is s)
\end{minted}
%
In this protocol the client sends a single string to the server which
replies with the same string.
%
We can use this specification to verify that either a client or a server implementation of
the protocol is correct.
%
For example, when testing a faulty server implementation SessionCheck will print the following:
%
\begin{verbatim}
Failed with:
Bad: get {is ""}

With trace:
Output {""}
InputViolates {is ""} "\n\r"
\end{verbatim}

To see the SessionCheck language in action we will briefly explore
using SessionCheck to specify a small book ordering service.
%
The idea of this protocol is that the client transmits a number of
books it wants to order to the server, followed by a
\mintinline{Haskell}{checkout} message.
%
The server then transmits back to the client the clients current
basket.
%
We hope that this small example is sufficient to see how SessionCheck
might be used to specify larger protocols.
%
We start by specifying the type of messages which may be transmitted
between the client and the server.
%
The client will transmit \mintinline{Haskell}{Request} messages and
the server will reply with \mintinline{Haskell}{Reply} messages.
%
In this simple example we get the ordinary Haskell types below.
%
\begin{minted}{Haskell}
  data Request  =  Order String | Checkout

  data Reply    =  Basket [String]
\end{minted}

The protocol contains a loop where the client orders books.
%
\begin{minted}{Haskell}
  loop :: Request :< t =>  [String] -> Spec t [String]
  loop books = do
    r <- anyRequest
    case r of
      Order book -> loop (book:books)
      Checkout   -> return books
\end{minted}
%
Having specified the loop we can put everything together into the final protocol.
%
\begin{minted}{Haskell}
  protocol :: (Request :< t, Reply :< t) =>  Spec t Reply
  protocol = do
    books <- loop []
    get (supersetOf books)
\end{minted}

So far we have only seen how we can specify and test one part of a protocol.
%
However, thanks to something called duality, a client specification gives rise
to a server specification without any effort.
%
The key idea of duality is that if a specification specifies one part
of a two-party protocol, then the same specfication with all instances
of \mintinline{Haskell}{send} replaced by \mintinline{Haskell}{get}
and vice-versa specifies the other.
%
In SessionCheck, duality is implemented as a function \mintinline{Haskell}{dual :: Spec t a -> Spec t a}.
%
The specification (not implementation) of \mintinline{Haskell}{dual} can be seen below.
%
\begin{minted}{Haskell}
  dual :: Spec t a   ->  Spec t a
  dual    (send p)    =  get p
  dual    (get p)     =  send p
  dual    stop        =  stop
  dual    (fail s)    =  fail s
  dual    (return a)  =  return a
  dual    (s >>= f)   =  dual s >>= dual . f
\end{minted}
%
To see duality in action consider the \mintinline{Haskell}{echo} protocol above.
%
When written using explicit \mintinline{Haskell}{(>>=)} the protocol looks like this
%
\begin{minted}{haskell}
  echo = send anyString >>= \ s -> get (is s)
\end{minted}
%
the \mintinline{Haskell}{dual} of which can be computed to
%
\begin{minted}{haskell}
  dual echo = get anyString >>= \ s -> send (is s)
\end{minted}
%
Which when written using the more convenient \mintinline{Haskell}{do} notation is simply
%
\begin{minted}{haskell}
  dual echo = do
    s <- get anyString
    send (is s)
\end{minted}
%
Which is clearly a specification of an \mintinline{Haskell}{echo} server.

\paragraph{Using SessionCheck to Test GRACe-like Tools}

We will briefly turn our attention to how SessionCheck could be employed
to test tools like the GRACeFUL RAT.
%
There are multiple communicating components in the GRACeFUL software architecture.
%
The two primary components are the visual editor, running as a client in a web browser,
and the GRACe server.
%
The GRACe server itself consists of two components, a front end which communicates with
the visual editor, and a back end which communicates with the the MiniZinc solver.
%
Both these avenues of communication could possibly be tested by SessionCheck.
%

To test the communication between the GRACe server and the visual editor we can model
the API calls between the client and the server as
two data types \mintinline{Haskell}{ClientRequest} and
\mintinline{Haskell}{ServerResponse}, defined as follows:
%
\begin{minted}{Haskell}
data ClientRequest =
    AskLibraries
  | SubmitProgram LibraryName ProgramRepresentation

data ServerResponse =
    Libraries   [Library]
  | Assignments [(VariableName, Value)]
  | Error503
\end{minted}

The specification needs to makes use of external knowledge about the system
being specified and tested.
%
The specific piece of knowledge required is what libraries the server has access
to.
%
The specification is written to be parametric in this information:

\begin{minted}{Haskell}
spec :: (ClientRequest :< t, ServerResponse :< t)
     => [Library] -> Spec t ()
spec allLibraries = do
  req <- get anyClientRequest
  case req of
    AskLibraries -> send (is $ Libraries allLibraries)
    SubmitProgram libName progRep -> send (validAssignments libName allLibraries progRep)
  spec allLibraries
\end{minted}
%stopzone
%stopzone is a vim hack, dont remove

We omit the definition of the predicate
\begin{minted}{Haskell}
validAssignments :: LibraryName -> [Library] -> ProgramRepresentation 
                 -> Predicate ServerResponse}
\end{minted}
in the interest of brevity.
%
Writing the predicates in this specifiation is not necessarily a simple task.
%
To describe the client we would need to define what a correct program representation is
and come up with a way to generate such a representation.

To sum up, SessionCheck provides a small DSL, implemented in Haskell,
for specifying communicating systems.
%
It benefits from the strong type system of Haskell, but also extends
the reach of the specification to a large class of communication
protocols, including cases when the ``other end'' of the communication
is not written in Haskell (as in the case of the GRACeFUL visual
editor).

\section{Solver Testing}
\todo{Solrun+Maximilian: Testing solvers and backends: challenges and partial solutions}
\input{solver-testing}


\section{Property based testing of GRACe programs}

Maximilian: Tell the story about bugs fixed in the compiler?

\todo{Solrun: try out sessioncheck before Jan.}

\todo{Max: fill in more based on using Jan.}

\section{Related Work}

This section presents a brief overview of related work and provides accounts
of how SessionCheck relates to them as well as how we may incorporate some of
the ideas present in the literature in future work.

\paragraph{Mocking}

Mocking refers to the practice of creating software components specifically
in order to exercise the functionality of a system under test.
%
As an example of a mockup, consider testing the functionality of a software
component, which we will call |dashboard|, in a vehicle computer which is
meant to read the speed of a vehicle and update the dashboard display
appropriately.
%
The computer has a simple interface consisting of two functions,
|readSpeed| and |updateDisplay|.
%
A mockup designed to test the |dashboard| component would consist of a sequence
of expected calls to |readSpeed| and |updateDisplay| as well as their
respective arguments and return values.
%
In a notation similar to that of Svenningsson et al. \cite{HughesMocking}
a mockup which expects the |readSpeed| and |updateDisplay| functions to be
called sequentially may look like the following:
%
\begin{minted}{Haskell}
    readSpeed() |-> 5.833 fs updateDisplay(speed, 21) |-> () fs eps
\end{minted}
%
This mockup specifies that the call to |readSpeed| will return |5.833| and that
the subsequent call to |updateDisplay| will be called with the arguments
|speed| and |21|.
%
In this case the speed returned by |readSpeed| is in m/s and the speed indicated
on the display is meant to be in km/h.
%
Previous work on frameworks for mocking for testing communicating parties
in two-party and multi-party protocols by Svenningsson et al. \cite{HughesMocking}
as well as the GoogleMock \cite{GoogleMock} and EasyMock \cite{EasyMock} tools
for C++ and Java respectively focus on mocking individual components.
%
SessionCheck improves on the state of the art in mocking by introducing
both the possibility of checking consistency of specifications as well as
mocking both parties of a two-party protocol using a single specification.
%

In the context of GRACeFUL, mocking is useful for testing a single
layer of the software stack in isolation.
%
Specifically, it can be used to test the GRACe server separately from
the visual editor front-end.

\paragraph{Contracts, Chaperone Contracts, and Monitors}
%
Contracts \cite{Contracts} are a way of extending functions to provide runtime
monitoring of pre- and post-conditions and assigning blame to code which
violates these conditions.
%
In their implementation of typed contracts Hinze et al. \cite{ContractsHinze}
treat contracts as refinements of ordinary Haskell types.
%
As an example consider the partial |head| function which takes a list and
returns the first element:
%
\begin{minted}{haskell}
  head :: [a] -> a
  head (x:xs) = x
\end{minted}
%
In the scheme of Hinze et al.\ a contract of |head| which specifies that |head|
may only be called on a non-empty list is written as:
%
\begin{minted}{haskell}
  headContract :: Contract ([a] -> a)
  headContract = prop (\xs -> not (null xs))  ->>  true
\end{minted}
%
Here |prop :: (a -> Bool) -> Contract a| takes a predicate and lifts
it to a contract, |true| is the contract which is always satisfied,
equivalent to |prop (const True)|, and the infix combinator |(->>)|
forms a contract for functions.

%
Finally, associating |head| with its contract |headContract| is done
using the function |assert :: Contract a -> a -> a|:
%
\begin{minted}{haskell}
  headWithContract :: [a] -> [a]
  headWithContract = assert headContract head
\end{minted}
%
When a programmer uses the new |headWithContract| function the input is
dynamically checked and an error is reported in case the contract is violated,
that is to say when |headWithContract| is called on the empty list.
%
Crucially, the programmer can also specify location information for each call to
|headWithContract|, which will extend contract violations errors with specific
information about which call to |headWithContract| failed.

Melgratti and Padovani \cite{ChaperoneContracts} introduce ``Chaperone
Contracts'', as a method for specifying higher-order two-party
protocols. (Higher-order here means protocols which can transmit
protocol endpoints over the network.)
%
While this work is similar to SessionCheck it does not address the problem
of mocking protocol end points.
%
Furthermore, while the interface for contracts is very similar to ours,
providing primitives similar to our |send| and |get|, the interface is not
monadic.
%
Rather, specifications need to be explicitly sequenced using the
|(@@) :: Spec -> Spec -> Spec| combinator.
%
As a result of this, dependent contracts, where the constraints in |send| and
|get| depend on previous sent and received values, are specified using
special |send_d :: (a -> Bool) -> (a -> Spec) -> Spec| and
|get_d :: (a -> Bool) -> (a -> Spec) -> Spec| combinators.
%
This introduces additional syntactic noise by making dependency more
explicit than it already is.

One important benefit of Melgratti and Padovani's work over ours is
their ability to write higher order specifications, where protocol
end-points (including associated specifications), may be transmitted
on the communication channels.
%
We believe that modest extensions to SessionCheck would allow us to
use our specifications as contracts in a way similar to Melgratti and
Padovani.
%
Doing this would effectively provide a more convenient (monadic)
language for specifying contracts for the subset of protocols which
are first order.
%

\paragraph{The Scribble Specification Language}
%
The Scribble specification language \cite{Scribble} is a stand alone language
which permits specification of multi-party protocols.
%
Scribble specifications can be used to derive monitors which monitor communicating
parties to find protocol violations, and to derive skeleton code for implementing
the protocol in the Java language \cite{Java}.
%
Scribble also features an analog of the |dual| operation, |project|, which turns a
global specification into a local one.
%
Both |dual| and |project| have their origins in the literature on session types
\cite{HondaSessionTypes, WadlerSessionTypes}.

Our work differs significantly from Scribble.
%
SessionCheck is focused on testing and simulating protocols, while the language
leverages as much of the Haskell host language as possible, making the implementation
simple and succinct.
%
The SessionCheck language being embedded means generating skeleton code from a
specification is more difficult.
%
However, we have techniques in mind for a version of SessionCheck which can handle
both testing, use as a monitor, and generating skeleton code, bringing SessionCheck
up to speed with Scribble.
%

\section{Conclusion}

\bibliographystyle{plain}

\bibliography{main}

\end{document}

From Y2 review: ``We suggest that deliverables consisting of software
products also contain a written document that includes motivations,
use cases, explanations, user’s manuals, and informal semantics (if
possible).''

Note that D4.4 and D2.5 are both deliverables of type

  "DEM: Demonstrator, Pilot, Plans",

which is not described in detail in the H2020 documentation.
