\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[unicode=true]{hyperref}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Patrik Jansson et al.},
            pdftitle={GRACeFUL D4.4: Testing and verification framework},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

%% Cezar
\usepackage[margin=1.60in]{geometry}
\usepackage[verbose]{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{rotating}
\usepackage{lscape}
\usepackage{float}
\usepackage{geometry}
\usepackage{framed}
\usepackage{xspace}
\usepackage{acronym}
\usepackage[square,numbers]{natbib}

%% Max
\usepackage{minted}
\usepackage{todonotes}

%% Alex
\newminted{haskell}{fontsize=\normalsize,xleftmargin=2mm,mathescape,linenos}
\newcommand{\haskell}[1]{\mintinline{haskell}|#1|}
\DefineShortVerb{\|}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\definecolor{GRACeFULblue}{rgb}{0.20,0.60,0.86}

\newcommand{\grace}{GRACeFUL\xspace}
\acrodef{GCM}{\grace Concept Map}
\acrodef{GMB}{Group Model Building}
\acrodef{DSL}{Domain Specific Language}
\acrodef{CFP}{Constraint Functional Program}
\acrodef{RAT}{Rapid Assessment Tool}
\acrodef{CRUD}{Climate Resilient Urban Design}
\acrodef{CLD}{Causal Loop Diagram}
\acrodef{JSON}{JavaScript Object Notation}
\acrodef{CP}{Constraint Program}
\hyphenation{GRACeFUL}

\author{}
\date{}

\begin{document}

\begin{center}
\includegraphics[width=5cm]{../coverpage/GRACeFULlogo.png}

\textcolor{GRACeFULblue}{Global systems Rapid Assessment tools\\
through Constraint FUnctional Languages}

\vspace{1cm}

FETPROACT-1-2014 Grant Nº 640954

\end{center}

\begin{framed}
\begin{center}
\Large
D4.4: Testing and verification framework\\[1ex]

\large
D4.4 Testing and verification framework for RATs\\
with applications to the CRUD case study\\[1ex]

\end{center}
\end{framed}

\vspace{1cm}

\noindent
\begin{tabular}{@{}ll@{}}
  Lead Participant:       & Chalmers (WP leader: P. Jansson)
\\Dissemination Level:    & PU
\\Document Version:       & Draft
\\Date of Submission:     & 201?-??-??
\\Due Date of Delivery:   & 2018-01-31
\end{tabular}

\newpage

\section*{D4.4 Testing and verification framework for RATs with
  applications to the CRUD case study}

Contributions by: Maximilian Algehed, Sólrún Einarsdóttir, Alex
Gerdes, and Patrik Jansson.

\begin{abstract}

This fourth deliverable (D4.4) of work package 4 presents a framework for
testing and verification of RATs.
%
The work leading up to this deliverable is within Task 4.5 ``Build a
testing and verification framework for RATs'' and the full source code
of the implementation is available on GitHub.


\end{abstract}

\vfill

\setcounter{tocdepth}{2}
\tableofcontents

\vfill


\newpage

\section{Introduction}

\input{intro}

\subsection{Property-based testing}
\todo{Alex: introduce property based testing: [before Jan]}
\input{intro-property-based-testing}

\section{}
\todo{Alex: type systems as another testing/verification technique we make use of. TypedValues}

\section{Testing Communicating Systems}
%
SessionCheck \cite{SessionCheck} is a tool developed in WP4 to test distributed systems like
the GRACeFUL editor.
%
The tool is focused on the communication protocols used between the components.
%
In the case of the GRACeFUL editor the protocol would be the REST API described in \cite{D4.3}. 
%
Typical testing of distributed systems is done by maintaining a database consisting of hundreds
or thousands of test-cases, each specifying the behaviour of one party in the protocol with
respect to a specific exchange of messages, a trace.
%
This approach is not ideal, as each test case is an artifact on its own which needs to be kept
in sync with the rest of the software.
%
SessionCheck relieves developers of the duty of maintaining hundreds of software
artifacts, replacing them with only three: the client, the server, and the SessionCheck specification.

\begin{figure}
  \begin{minted}{Haskell}
send    :: a :< t => Predicate a -> Spec t a
get     :: a :< t => Predicate a -> Spec t a
stop    :: Spec t a
fail    :: String -> Spec t a
return  :: a -> Spec t a
(>>=)   :: Spec t a -> (a -> Spec t b) -> Spec t b
-- Derived combinators
choose  :: (Eq a, a :< t) => [a] -> Spec t a
branch  :: (Eq a, a :< t) => [a] -> Spec t a
  \end{minted}
  \caption{\label{fig:SessionCheck:language} The SessionCheck language}
\end{figure}

To see the SessionCheck specfication language in action, consider a simple protocol between a server and a
client which requires the client to transmit two positive integers and receive back from the server their sum.
%
In SessionCheck, this specification would be written as follows:
%

\begin{minted}{Haskell}
protocol :: Spec Int Int
protocol = do
  a <- send posInt
  b <- send posInt
  get (is (a + b))
\end{minted}

%
SessionCheck specifications are written from the point of view of a particular party, in this case the client.
%
We may as well have written the same specification from the point of view of the server,
in which case it would look like this:
%

\begin{minted}{Haskell}
protocol' :: Spec Int Int
protocol' = do
  a <- get posInt
  b <- get posInt
  send (is (a + b))
\end{minted}

%
It is no coincidence that the two specifications are very similar, and SessionCheck can work equally well with
both, as we will see shortly.

The SessionCheck specification language is a domain specific language embedded in the Haskell \cite{Haskell}
programming language.
%
Being an embedded language means that the language primitives in SessionCheck are
implemented as Haskell data types and functions.
%
The language primitives in SessionCheck can be seen in Figure \ref{fig:SessionCheck:language}.
%
The type argument \texttt{t} in the type \texttt{Spec t a} denotes the type of messages
being delivered on the channel on which the system under test is communicating
with SessionCheck.
%
The \texttt{send} and \texttt{get} primitives represent obligations for the respective party to send a message
which is compliant with the given \texttt{Predicate}, more on this soon.
%
The constraint \texttt{a :< t} denotes a subtyping relation between \texttt{a} and \texttt{t}.
%
That is, any value of type \texttt{a} can be transformed into value of type \texttt{t}, and it may be
possible to transform a value of type \texttt{t} into value of type \texttt{a}.
%
Included in the interface are also the \texttt{fail} and \texttt{stop} functions.
%
The \texttt{stop} primitive specifies that the protocol session is terminated.
%
Unlike \texttt{send}, \texttt{get}, and \texttt{stop}, \texttt{fail} does not directly correspond to an action in the protocol.
%
Rather it allows the user to specify conditions for when the system being tested by SessionCheck fails
which are not directly coupled to direct constraints on messages.
%
The \texttt{choose} and \texttt{branch} primitives are not actually primitive operations, rather they are derived from
the rest of the interface.
%
The specification \texttt{choose xs} reads ``send one of the values in \texttt{xs}'', while \texttt{branch xs} reads ``get one
of the values in \texttt{xs}''.

The primitives described above do not permit small specifications, like \texttt{send anyInt} and \texttt{get anyBool}, to
be composed to form more complex specifications.
%
For this purpose SessionCheck also supports the standard \texttt{Monad} interface \cite{WadlerMonad}, which contains the
two primitive operations \texttt{return} and \texttt{(>>=)} (pronounced ``bind'').
%
The bind operator allows specifications to be composed by taking a specification, \texttt{s}, and a function which
creates a specification from a value, \texttt{f}, and composing them to form the specification \texttt{s >>= f} which means
``first the protocol behaves like \texttt{s}, then whatever value is produced at the end of \texttt{s} is fed to \texttt{f} to produce
a new specification to follow''.
%
As an example, consider the case where \texttt{s = send anyInt} and \texttt{f x = send (greaterThan x)}, here \texttt{s >>= f} is
a specification which first requires the end-point to send an \texttt{Int} and then to send another \texttt{Int} which is greater
than the first one.
%
The \texttt{do ...} notation in the above examples is syntactic sugar for successive uses of \texttt{(>>=)} and lambda abstraction
\texttt{\ x -> e}, where the expression \texttt{\ x -> e} denotes a function where the variable \texttt{x} is used to bind the input of
the function in the output \texttt{e}.
%
When written using explicit \texttt{(>>=)} the specification of \texttt{protocol} would look like this:
%

\begin{minted}{haskell}
protocol :: Spec Int Int
protocol =
  send posInt >>= \ a ->
  send posInt >>= \ b ->
  get (is (a + b))
\end{minted}


%
Supporting the generic \texttt{Monad} interface means that we get several useful combinators ``for free'', like
\texttt{(>>) :: Spec t a -> Spec t b -> Spec t b} which sequences two independent specifications, and
\texttt{forever :: Spec t a -> Spec t b} which repeats a specification indefinitely.
%
Finally, the \texttt{return} function simply wraps a value in a specification.
%
It represents no obligation on either part of the communication protocol, but rather is part of the standard
monad interface.
%

\begin{figure}
  \begin{minted}{haskell}
    echo = do
      s <- send anyString
      get (is s)
  \end{minted}
  \caption{\label{fig:SessionCheck:echo} The \texttt{echo} protocol}
\end{figure}

See Figure \ref{fig:SessionCheck:echo} for an example of a SessionCheck specification.
%
The specification specifies the \texttt{echo} protocol, in this protocol the client sends
a single string to the server which replies with the same string.
%
We can use this specification to verify that either a client or a server implementation of
the protocol is correct.
%
For example, when testing a faulty server implementation SessionCheck will print the following:
%
\begin{verbatim}
Failed with:
Bad: get {is ""}

With trace:
Output {""}
InputViolates {is ""} "\n\r"
\end{verbatim}

To see the SessionCheck language in action we will briefly explore using SessionCheck
to specify a small book ordering service.
%
The idea of this protocol is that the client transmits a number of books it wants to order to the
server, followed by a \texttt{checkout} message, the server then transmits back to the client
the clients current basket. 
%
We hope that this small example is sufficient to see how SessionCheck might be used to
specify larger protocols.
%
We will begin by specifying the type of messages which may be transmitted between the client and the
server.
%
The client will transmit \texttt{Request} messages and the server will reply with \texttt{Reply} messages.
%
In this simple example we get the ordinary Haskell types below.

\begin{minted}{Haskell}
data Request = Order String | Checkout

data Reply = Basket [String]
\end{minted}

The protocol contains a loop where the client orders books.

\begin{minted}{Haskell}
  loop :: Request :< t => [String] -> Spec t [String]
  loop books = do
    r <- anyRequest
    case r of
      Order book -> loop (book:books)
      Checkout   -> return books
\end{minted}

Having specified the loop we can put everything together into the final protocol.

\begin{minted}{Haskell}
  protocol :: (Request :< t, Reply :< t) => Spec t Reply
  protocol = do
    books <- loop []
    get (supersetOf books)
\end{minted}

So far we have only seen how we can specify and test one part of a protocol.
%
However, thanks to something called duality a client specification gives rise
to a server specification without any effort.
%
The key idea of duality is that if a specification specifies one part of a two-party
protocol, then the same specfication with all instances of \texttt{send} replaced by
\texttt{get} and vice-verse specifies the other.
%
In SessionCheck, duality is implemented as a function \texttt{dual :: Spec t a -> Spec t a}.
%
The specification (not implementation) of \texttt{dual} can be seen below.
\\~\\

\begin{minipage}{\linewidth}
\begin{minted}{haskell}
  dual :: Spec t a -> Spec t a
  dual (send p)   = get p
  dual (get p)    = send p
  dual stop       = stop
  dual (fail s)   = fail s
  dual (return a) = return a
  dual (s >>= f)  = dual s >>= dual . f
\end{minted}
\end{minipage}

To see duality in action consider the \texttt{echo} protocol above.
%
When written using explicit \texttt{(>>=)} the protocol looks like this

\begin{minted}{haskell}
  echo = send anyString >>= \ s -> get (is s)
\end{minted}

the \texttt{dual} of which can be computed to

\begin{minted}{haskell}
  dual echo = get anyString >>= \ s -> send (is s)
\end{minted}

Which when written using the more convenient \texttt{do} notation is simply

\begin{minted}{haskell}
  dual echo = do
    s <- get anyString
    send (is s)
\end{minted}

Which is clearly a specification of an \texttt{echo} server.

\section{Solver Testing}
\todo{Solrun+Maximilian: Testing solvers and backends: challenges and partial solutions}
\input{solver-testing}


\section{Property based testing of GRACe programs}

Maximilian: Tell the story about bugs fixed in the compiler?

\todo{Solrun: try out sessioncheck before Jan.}

\todo{Max: fill in more based on using Jan.}

\section{Conclusion}

\end{document}

From Y2 review: ``We suggest that deliverables consisting of software
products also contain a written document that includes motivations,
use cases, explanations, user’s manuals, and informal semantics (if
possible).''

Note that D4.4 and D2.5 are both deliverables of type

  "DEM: Demonstrator, Pilot, Plans",

which is not described in detail in the H2020 documentation.
