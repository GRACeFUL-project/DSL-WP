\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[unicode=true]{hyperref}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Patrik Jansson et al.},
            pdftitle={GRACeFUL D4.4: Testing and verification framework},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

%% Cezar
\usepackage[margin=1.60in]{geometry}
\usepackage[verbose]{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{rotating}
\usepackage{lscape}
\usepackage{float}
\usepackage{geometry}
\usepackage{framed}
\usepackage{xspace}
\usepackage{acronym}
\usepackage[square,numbers]{natbib}

%% Max
\usepackage{minted}
\usepackage{todonotes}

%% Alex
\newminted{haskell}{fontsize=\normalsize,xleftmargin=2mm,mathescape}
\newcommand{\haskell}[1]{\mintinline{haskell}|#1|}
\DefineShortVerb{\|}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\definecolor{GRACeFULblue}{rgb}{0.20,0.60,0.86}

\newcommand{\grace}{GRACeFUL\xspace}
\acrodef{GCM}{\grace Concept Map}
\acrodef{GMB}{Group Model Building}
\acrodef{DSL}{Domain Specific Language}
\acrodef{CFP}{Constraint Functional Program}
\acrodef{RAT}{Rapid Assessment Tool}
\acrodef{CRUD}{Climate Resilient Urban Design}
\acrodef{CLD}{Causal Loop Diagram}
\acrodef{JSON}{JavaScript Object Notation}
\acrodef{CP}{Constraint Program}
\hyphenation{GRACeFUL}

\author{}
\date{}

\begin{document}

\begin{center}
\includegraphics[width=5cm]{../coverpage/GRACeFULlogo.png}

\textcolor{GRACeFULblue}{Global systems Rapid Assessment tools\\
through Constraint FUnctional Languages}

\vspace{1cm}

FETPROACT-1-2014 Grant Nº 640954

\end{center}

\begin{framed}
\begin{center}
\Large
D4.4: Testing and verification framework\\[1ex]

\large
Testing and verification framework for RATs\\
with applications to the CRUD case study\\[1ex]

\end{center}
\end{framed}

\vspace{1cm}

\noindent
\begin{tabular}{@{}ll@{}}
  Lead Participant:       & Chalmers (WP leader: P. Jansson)
\\Dissemination Level:    & PU
\\Document Version:       & Draft
\\Date of Submission:     & 2018-0?-??
\\Due Date of Delivery:   & 2018-01-31
\end{tabular}

Authors: Maximilian Algehed, Sólrún Einarsdóttir, Alex Gerdes, and
Patrik Jansson.

\begin{abstract}

This fourth deliverable (D4.4) of work package 4 presents a framework for
testing and verifying communicating systems.
%
The work leading up to this deliverable is within Task 4.5 ``Build a
testing and verification framework for Rapid Assessment Tools (RATs)''
and the full source code of the implementation is available on GitHub.

\end{abstract}
\newpage

\section{Introduction}
\label{sec:intro}

The GRACeFUL project can be described as a stack of four layers,
starting with stakeholder interaction (group model building, WP2) at
the top, then the graphical user interface (GRACeFUL editor, WP3), the
domain specific language for models and constraints (GRACe DSL, WP4)
and finally the constraint programming (CP) backend providing
efficient solution algorithms (WP5).
%
In addition to the GRACe DSL, WP4 has developed a RESTful server around our DSL,
called GRACeServer, for handling webservice requests. The server communicates
both ``upwards'' to the GRACeFUL editor and ``downwards'' to the CP layer.
%
This deliverable describes our methods for verifying correctness of
this communication.

The division into frontend, server and backend is very common in
software systems and this means that our results should be applicable
for a wide range of other systems.
%
Our approach to software verification is based on three main parts:
%
declarative programming with strong types, property-based testing in
general, and the SessionCheck tool for testing communicating systems
in particular.

\paragraph{Scope and limitations}

This deliverable (D4.4) covers the software technology side of testing
and verification of RATs.
%
The CRUD RAT evaluation based on stakeholder sessions is reported
elsewhere [D2.6 Evaluation Report CRUD RATs: m36] as is the
interactivity and usability of the visual front-end [T3.4, D3.3 VA EDA
Tool Prototype (RAT components): m34].

\paragraph{Rapid Assessment Tools}

RATs are used in large organisations like the World Bank and the
United Nations to assess risks and needs and to make plans for
improvement.
% http://www.wahooas.org/mshdvd2/assess_tools_MWL_Eng.htm
% http://www.fao.org/docrep/015/i2495e/i2495e06.pdf
In GRACeFUL the main focus is on Climate Resilient Urban Design, but
the software developed in the project could be used for almost any
Global Systems Science problem.


\section{GRACeFUL software architecture}
\label{sec:architecture}
In this section we briefly describe the different layers of
the GRACeFUL software stack and how testing and
verification is performed on each layer.

\subsubsection*{Visual Editor}

The top layer of the software stack is the visual editor.
%
It provides a graphical user interface where the user can build GCMs
as a graphical map from available components.
%
The visual editor is implemented in the programming language
JavaScript, using the Data Driven Documents library (D3.js).
%
The code for the visual editor can be found in the
\href{https://github.com/GRACeFUL-project}{GRACeFUL-project} GitHub
repository
\href{https://github.com/GRACeFUL-project/GRACeFULEditor}{GRACeFULEditor}.

The visual editor is described in deliverabe D3.3 including how it can be
accessed\footnote{\url{http://vocol.iais.fraunhofer.de/graceful-rat/static/}},
how it can be used, and more details on how it is implemented.
%
The editor was evaluated by stakeholders in November 2017, details can
be found in deliverable D2.6.

\subsubsection*{GRACe}

GRACe is a domain specific language embedded in Haskell. It is used to express
GRACeFUL concept maps (GCMs) and GCM library components. GRACe programs
representing GCMs are compiled to haskelzinc constraint programs, and the
resulting solutions are passed back to GRACe. The DSL is described in detail in
deliverable D4.2. We use different test approaches to validate the correctness
of our DSL implementation. In Section~\ref{sec:verification} we explain how we
use strong types and property-based testing. In addition to these two approaches,
we also have a set of unit test cases, which test the entire software stack.

\subsubsection*{GCM component libraries}

The visual editor allows users to create a GRACeFUL Concept Map with components
of a chosen library. Components are written in GRACe and are grouped in a
library, for example a library with CRUD components. The visual editor can query
the components available in a library using its identifier. A JSON
representation of the components are sent to the visual editor.

The following code shows an example CRUD library, where |rain| and |pump| are
|GCM| components:
\begin{haskellcode}
library :: Library
library = Library "crud"
    [ item "rain" $
        rain ::: "amount" #
          tFloat .-> tGCM          (tPort $ "rainfall" # tInt)
    , item "pump" $
        pump ::: "capacity" #
          tFloat .-> tGCM (tPair   (tPort $ "inflow"   # tInt)
                                   (tPort $ "outflow"  # tInt))
    ]
\end{haskellcode}
The example library makes use of Typed Values, which are explained in
Section~\ref{sec:verification} (the syntax |"text" #| is used to tag
ports with their names).
%
We have implemented tools for property-based testing of GRACe components,
described in Section~\ref{sec:GCMP}.

\subsubsection*{Communication with visual editor}

The GRACeServer provides a RESTful API and uses JSON\footnote{JavaScript Object
Notation} as the exchange format. The server offers the following webservices:
\begin{quote}
\begin{description}
\item [\haskell{libraries}] returns a list with the available component libraries
\item [\haskell{library (id)}] has a library identifier parameter and returns
  a list with a description (in JSON) of the all library components
\item [\haskell{submit (gcm)}] takes a GRACeFUL Concept Map description as
  argument, which is translated to a GRACe DSL program, and returns the result
  of the constraint solver
\end{description}
\end{quote}
The visual editor, developed in work package 3, communicates with the GRACeServer
by making service calls. The GRACeServer is available as the \texttt{RestAPI}
executable in the \href{https://github.com/GRACeFUL-project/GRACe}{GRACe}
repository.

We have developed the tool SessionCheck, described in
Section~\ref{sec:SessionCheck}, to test the communication of systems such as this.

\subsubsection*{Haskelzinc}

Haskelzinc is a Haskell interface to the MiniZinc constraint
programming language.
%
It provides a Haskell DSL for building MiniZinc model representations and a parser that returns a representation of the solutions obtained
by running the MiniZinc model.

The latest version of haskelzinc (currently 0.3) is available from
\url{https://hackage.haskell.org/package/haskelzinc}.


\section{Verification through types and tests}
\label{sec:verification}

Rapid Assessment Tools are used to evaluate plans for problems in
Global System Science, such as Climate Resilient Urban Design.
%
The evaluation output that is produced by the GRACeFUL tools should be
reliable.
%
This implies that the software behind the tools that we have developed
should ideally be free of errors.
%
It is well known that this is an utopia and not realistic.
%
We can, however, do our best to keep the number of errors as low as
possible.
%
In this section we describe the two approaches to software
verification that we have used in this project: types and
property-based testing.

\subsection{Strong types}

Types are used to help the programmer to write code which doesn't "go
wrong" and helps the compiler generate efficient code.
%
But types can also be seen as \emph{specifications} of parts of a
program, such as functions and expressions.
%
A type checker, normally part of a compiler, checks if the declared
types match with the expected ones.
%
A programmer can use a type checker to (semi-)formally verify the
given specification, in the form of type declarations and
annotations.
%
In this sense, type systems can be regarded as the most used formal
verification.
%
It is of course a light-weight kind of formal verification, but
nevertheless very useful.

We have used types extensively in the GRACeFUL project, in particular
in our domain specific language GRACe, the GRACeServer, and in
Haskelzinc, the interface to the constraint programming layer.
%
Our DSL for GRACeFUL concept maps is embedded in Haskell, which is a
strongly typed functional programming language.
%
Using Haskell's type system, we can prevent a DSL user from making
mistakes.

An end user of the GRACeFUL tool chain is most likely not programming
directly in Haskell using our GRACe DSL, but using the Visual Editor
from Work Package 3 instead.
%
This poses a problem since the communication with the Visual Editor goes
via an untyped channel.
%
An additional problem is that we want to group |GCM| components, which
we mentioned in Section~\ref{sec:intro}, in a library, which is a
challenge if you want to do this in a type safe manner.
%
|GCM| components can have many different types, which makes it hard to
collect them in a data type, such as a list.

We have addressed the above issues with \emph{Typed Values}, which are
related to the |Typeable| and |Dynamic| Haskell
libraries~\cite{DataDynamic}.
%
We give a short description of Typed Values, leaving out many
implementation details (which can be found in the GRACeFUL code
repository on github).
%
The key idea behind Typed Values is to combine a value with its
\emph{type representation}.
%
A type representation can be implemented as follows in Haskell:
%
\begin{haskellcode}
data Type t where
  -- Base types
  TInt   :: Type Int
  TBool  :: Type Bool
  -- Annotations
  Tag   :: String -> Type t -> Type t
  -- Lists
  List  :: Type t -> Type [t]
  -- Functions
  (:->) :: Type a -> Type b -> Type (a -> b)
\end{haskellcode}
%
We use the above Generalised Algebraic DataType (GADT) to encode a
type representation.
%
The constructor |TInt|, for example, represents the |Int| type.
%
The constructor for the list type representation takes another type
representation as argument.
%
So, the |List TBool| value represents the type ``list of boolean''.
%
The |Tag| constructor is used to annotate a type's representation and
leaves the represented type untouched.
%
We can use such annotations to add meta-data (visual appearance in the
editor, like port names and icons).
%
Finally, the |(:->)| constructor can be used to represent function
types.

We use the type representation |Type t| to create a Typed Value,
implemented with the following GADT:
%
\begin{haskellcode}
data TypedValue where
  (:::) :: a -> Type a -> TypedValue
\end{haskellcode}
%
Note that type variable |a| does not appear in the result type.
%
We combine a value, of type |a|, with its type representation, of type
|Type a|.
%
Using this data type we can hide the type of a value, and turn it into
an untyped value.
%
We can, for instance, put values of different type into a list of
Typed Values.
%
This addresses one of the issues we identified above.
%
It is important the type representation is part of a Typed Value;
%
it allows us to extract the (typed) value, of type |a|, from a
|TypedValue|, that is we can go back to the typed realm in a type safe
manner!

This is, unfortunately, not as easy as it may seem.
%
We need to have a way to convince the Haskell compiler that two type
representations encode the \emph{same} type.
%
The following data type and type equality function does this:
%
\begin{haskellcode}
data a :~: b where
  Refl :: a :~: a

(?=) :: Type a -> Type b -> Maybe (a :~: b)
TInt         ?= TInt       = return Refl
TBool        ?= TBool      = return Refl
Tag t        ?= Tag t'     = t ?= t'
(List t)     ?= (List t')  = do
  Refl <- t  ?= t'
  return Refl
(t0 :-> t1)  ?= (t0' :-> t1') = do
  Refl <- t0 ?= t0'
  Refl <- t1 ?= t1'
  return Refl
\end{haskellcode}
%
The actual implementation of Typed Values is much more involved, but
in essence the same as the code showed above.
%
We use these Typed Values to create libraries of |GCM| components, and
to communicate with the untyped outside world.
%
Using these Typed Values we can enjoy the benefits of types as long as
possible.

Using a strongly typed programming language, such as Haskell, and
making good use of the types allows programmers to be more confident
about their code and catches many mistakes.
%
Alas, it does not prevent all mistakes and it is necessary to test our
implementation, to even further increase our confidence.
%
The next section explains the type of testing we have used in this
project.

\subsection{Property-based testing}

A traditional way of testing software is using so-called unit tests.
%
An unit test case specifies some input data along with the expected
output.
%
We use these test cases to assure that the software is behaving as
expected.
%
For real-life sized software projects, however, there are many test
cases needed to get a decent test coverage, which makes maintenance
more difficult.
%
Moreover, it is hard to think of all the corner cases that may be
present in the software.

An complementing approach is \emph{property-based testing}, which
verifies software against particular properties that the software
should have.
%
A property can be regarded as an abstraction of many unit tests.
%
These properties should hold for \emph{all} inputs, which would be
impossible to do by hand, but the property-based testing framework
that we use (QuickCheck~\cite{QuickCheck}) can actually
\emph{generate} input data automatically.
%
QuickCheck uses generated random input data to test such properties.
%
Properties are powerful: a good property gives a strong specification
for a large set of test data.

QuickCheck is a well known implementation of property-based testing,
and is available in many programming languages.
%
QuickCheck verifies properties by generating a large number of random
test cases, and reports test cases for which the property fails.

For example, a property of the |reverse| function from the Haskell
standard library (the |Prelude|) is that if we reverse a list twice,
we end up with the same list.
%
This can be expressed in Haskell QuickCheck as follows:
%
\begin{haskellcode}
propTwice :: [Int] -> Bool
propTwice = \ xs -> xs == reverse (reverse xs)
\end{haskellcode}
%
We can validate such a property by calling |quickCheck|:
\begin{minted}{shell}
> quickCheck propTwice
+++ OK, passed 100 tests.
\end{minted}
The above evaluation shows that the |reverse| function most likely
fulfills the |propTwice| property.
%
When QuickCheck finds a failing test case (a counterexample to the
property), it shrinks the failing test case automatically, by
searching for similar, but smaller test cases that also fail.
%
The result of shrinking is a minimal failing test case, and this
simplifies the debugging process.

Our tool SessionCheck, described in Section~\ref{sec:SessionCheck},
uses ideas from property-based testing to test communicating systems.
%
And in Section~\ref{sec:GCMP} we describe our property-based testing
of programs written in GRACe.

\section{Testing Communicating Systems}
\label{sec:SessionCheck}
%
SessionCheck \cite{SessionCheck} is a tool developed in WP4 to test distributed systems like
the GRACeFUL editor.
%
The tool is focused on the communication protocols used between the components.
%
In the case of the GRACeFUL editor the protocol would be the REST API described in deliverable D4.3. %\cite{D4.3}
%
But, as the tool can do more than that, we here give a mini-tutorial
of how to use SessionCheck in general.

Typical testing of distributed systems is done by maintaining a database consisting of hundreds
or thousands of test-cases, each specifying the behaviour of one party in the protocol with
respect to a specific exchange of messages, a trace.
%
This approach is not ideal, as each test case is an artifact on its own which needs to be kept
in sync with the rest of the software.
%
SessionCheck relieves developers of the duty of maintaining hundreds of software
artifacts, replacing them with only three: the client, the server, and the SessionCheck specification.

To see the SessionCheck specfication language in action, consider a
simple protocol between a server and a client which requires the
client to transmit two positive integers and receive back from the
server their sum.
%
In SessionCheck, this specification would be written as follows:
%

\begin{minted}{Haskell}
  protocol :: Spec Int Int
  protocol = do
    a <- send posInt
    b <- send posInt
    get (is (a + b))
\end{minted}

%
SessionCheck specifications are written from the point of view of a particular party, in this case the client.
%
We may as well have written the same specification from the point of view of the server,
in which case it would look like this:
%

\begin{minted}{Haskell}
  protocol' :: Spec Int Int
  protocol' = do
    a <- get posInt
    b <- get posInt
    send (is (a + b))
  \end{minted}

%
It is no coincidence that the two specifications are very similar, and SessionCheck can work equally well with
both, as we will see shortly.

\begin{figure}[tbp]
  \begin{minted}{Haskell}
    data Spec t a   -- SessionCheck spec. for channel type t

    send    ::  a :< t =>  Predicate a ->       Spec t a
    get     ::  a :< t =>  Predicate a ->       Spec t a
    stop    ::                                  Spec t a
    fail    ::  String ->                       Spec t a
    return  ::  a ->                            Spec t a
    (>>=)   ::  Spec t a -> (a -> Spec t b) ->  Spec t b

    -- Derived combinators
    choose  :: (Eq a, a :< t) =>  [a] ->       Spec t a
    branch  :: (Eq a, a :< t) =>  [a] ->       Spec t a
  \end{minted}
  \caption{\label{fig:SessionCheck:language} The SessionCheck language}
\end{figure}
%
The SessionCheck specification language is a domain specific language embedded in the Haskell \cite{Haskell}
programming language.
%
Being an embedded language means that the language primitives in SessionCheck are
implemented as Haskell data types and functions.
%
The language primitives in SessionCheck can be seen in Figure \ref{fig:SessionCheck:language}.
%
The type argument \mintinline{Haskell}{t} in the type \mintinline{Haskell}{Spec t a} denotes the type of messages
being delivered on the channel on which the system under test is communicating
with SessionCheck.
%
The \mintinline{Haskell}{send} and \mintinline{Haskell}{get} primitives represent obligations for the respective party to send a message
which is compliant with the given \mintinline{Haskell}{Predicate}, more on this soon.
%
The type constraint \mintinline{Haskell}{a :< t} (for \mintinline{Haskell}{send} and
\mintinline{Haskell}{get}) denotes a subtyping relation between \mintinline{Haskell}{a} and
\mintinline{Haskell}{t}.
%
That is, any value of type \mintinline{Haskell}{a} can be transformed into value of type \mintinline{Haskell}{t}, and it may be
possible to transform a value of type \mintinline{Haskell}{t} into value of type \mintinline{Haskell}{a}.
%

Included in the interface are also the \mintinline{Haskell}{stop} and \mintinline{Haskell}{fail} functions.
%
The \mintinline{Haskell}{stop} primitive specifies that the protocol session is successfully terminated.
%
The behaviour of \mintinline{Haskell}{stop} is specified by the equation \mintinline{Haskell}{stop >>= f = stop}.
%
Unlike \mintinline{Haskell}{send}, \mintinline{Haskell}{get}, and \mintinline{Haskell}{stop},
the \mintinline{Haskell}{fail} primitive does not directly correspond to an action in the protocol.
%
Rather it allows the user to specify conditions, for when the system being tested by SessionCheck fails,
which are not directly coupled to constraints on messages.
%
The \mintinline{Haskell}{choose} and \mintinline{Haskell}{branch} primitives are not actually
primitive operations, rather they are derived from (implemented using)
the rest of the interface.
%
The specification \mintinline{Haskell}{choose xs} reads ``send one of the values in \mintinline{Haskell}{xs}'',
while \mintinline{Haskell}{branch xs} reads ``get one
of the values in \mintinline{Haskell}{xs}''.

The primitives explained so far do not permit small specifications
(like \mintinline{Haskell}{send anyInt} and \mintinline{Haskell}{get anyBool}) to be composed to
form more complex specifications.
%
For this purpose SessionCheck also supports the standard \mintinline{Haskell}{Monad} interface~\cite{WadlerMonad}, which contains the
two primitive operations \mintinline{Haskell}{return} and \mintinline{Haskell}{(>>=)} (pronounced ``bind'').
%
The bind operator allows specifications to be composed by taking a specification, \mintinline{Haskell}{s}, and a function which
creates a specification from a value, \mintinline{Haskell}{f}, and composing them to form the specification \mintinline{Haskell}{s >>= f} which means
``first the protocol behaves like \mintinline{Haskell}{s}, then whatever value is produced at the end of \mintinline{Haskell}{s} is fed to \mintinline{Haskell}{f} to produce
a new specification to follow''.
%
As an example, consider the case where \mintinline{Haskell}{s = send anyInt} and \mintinline{Haskell}{f x = send (greaterThan x)}, here \mintinline{Haskell}{s >>= f} is
a specification which first requires the end-point to send an \mintinline{Haskell}{Int} and then to send another \mintinline{Haskell}{Int} which is greater
than the first one.
%
The \mintinline{Haskell}{do ...} notation in the above examples is syntactic sugar for successive uses of \mintinline{Haskell}{(>>=)} and lambda abstraction
\mintinline{Haskell}{\ x -> e}, where the expression \mintinline{Haskell}{\ x -> e} denotes a function where the variable \mintinline{Haskell}{x} is used to bind the input of
the function in the (output) expression \mintinline{Haskell}{e}.
%
When written using explicit \mintinline{Haskell}{(>>=)} the specification of \mintinline{Haskell}{protocol} could look like this:
%
\begin{minted}{haskell}
protocol :: Spec Int Int
protocol = send posInt >>= \ a -> send posInt >>= \ b -> get (is (a + b))
\end{minted}


%
Supporting the generic \mintinline{Haskell}{Monad} interface means that we get several useful combinators ``for free'', like
\mintinline{Haskell}{(>>) :: Spec t a -> Spec t b -> Spec t b} which sequences two independent specifications, and
\mintinline{Haskell}{forever :: Spec t a -> Spec t b} which repeats a specification indefinitely.
%
Finally, the \mintinline{Haskell}{return} function simply wraps a value in a specification.
%
It represents no obligation on either part of the communication protocol, but rather is part of the standard
monad interface.
%

% \begin{figure}
%   \begin{minted}{haskell}
%     echo = do
%       s <- send anyString
%       get (is s)
%   \end{minted}
%   \caption{\label{fig:SessionCheck:echo} The \mintinline{Haskell}{echo} protocol}
% \end{figure}
% %
As a third example of a SessionCheck specification we can take the \mintinline{Haskell}{echo} protocol:
%
\begin{minted}{haskell}
  echo = do
    s <- send anyString
    get (is s)
\end{minted}
%
In this protocol the client sends a single string to the server which
replies with the same string.
%
We can use this specification to verify that either a client or a server implementation of
the protocol is correct.
%
For example, when testing a faulty server implementation SessionCheck will print the following:
%
\begin{verbatim}
Failed with:
Bad: get {is ""}

With trace:
Output {""}
InputViolates {is ""} "\n\r"
\end{verbatim}

To see the SessionCheck language in action we will briefly explore
using SessionCheck to specify a small book ordering service.
%
The idea of this protocol is that the client transmits a number of
books it wants to order to the server, followed by a
\mintinline{Haskell}{checkout} message.
%
The server then transmits back to the client the clients current
basket.
%
We hope that this small example is sufficient to see how SessionCheck
might be used to specify larger protocols.
%
We start by specifying the type of messages which may be transmitted
between the client and the server.
%
The client will transmit \mintinline{Haskell}{Request} messages and
the server will reply with \mintinline{Haskell}{Reply} messages.
%
In this simple example we get the ordinary Haskell types below.
%
\begin{minted}{Haskell}
  data Request  =  Order String | Checkout

  data Reply    =  Basket [String]
\end{minted}

The protocol contains a loop where the client orders books.
%
\begin{minted}{Haskell}
  loop :: Request :< t =>  [String] -> Spec t [String]
  loop books = do
    r <- anyRequest
    case r of
      Order book -> loop (book:books)
      Checkout   -> return books
\end{minted}
%
Having specified the loop we can put everything together into the final protocol.
%
\begin{minted}{Haskell}
  protocol :: (Request :< t, Reply :< t) =>  Spec t Reply
  protocol = do
    books <- loop []
    get (supersetOf books)
\end{minted}

So far we have only seen how we can specify and test one part of a protocol.
%
However, thanks to something called duality, a client specification gives rise
to a server specification without any effort.
%
The key idea of duality is that if a specification specifies one part
of a two-party protocol, then the same specfication with all instances
of \mintinline{Haskell}{send} replaced by \mintinline{Haskell}{get}
and vice-versa specifies the other.
%
In SessionCheck, duality is implemented as a function \mintinline{Haskell}{dual :: Spec t a -> Spec t a}.
%
The specification (not implementation) of \mintinline{Haskell}{dual} can be seen below.
%
\begin{minted}{Haskell}
  dual :: Spec t a   ->  Spec t a
  dual    (send p)    =  get p
  dual    (get p)     =  send p
  dual    stop        =  stop
  dual    (fail s)    =  fail s
  dual    (return a)  =  return a
  dual    (s >>= f)   =  dual s >>= dual . f
\end{minted}
%
To see duality in action consider the \mintinline{Haskell}{echo} protocol above.
%
When written using explicit \mintinline{Haskell}{(>>=)} the protocol looks like this
%
\begin{minted}{haskell}
  echo = send anyString >>= \ s -> get (is s)
\end{minted}
%
the \mintinline{Haskell}{dual} of which can be computed to
%
\begin{minted}{haskell}
  dual echo = get anyString >>= \ s -> send (is s)
\end{minted}
%
Which when written using the more convenient \mintinline{Haskell}{do} notation is simply
%
\begin{minted}{haskell}
  dual echo = do
    s <- get anyString
    send (is s)
\end{minted}
%
Which is clearly a specification of an \mintinline{Haskell}{echo} server.

\paragraph{Using SessionCheck to Test GRACe-like Tools}

We will briefly turn our attention to how SessionCheck could be employed
to test tools like the GRACeFUL RAT.
%
There are multiple communicating components in the GRACeFUL software architecture.
%
The two primary components are the visual editor, running as a client in a web browser,
and the GRACe server.
%
The GRACe server itself consists of two components, a front end which communicates with
the visual editor, and a back end which communicates with the the MiniZinc solver.
%
Both these avenues of communication could possibly be tested by SessionCheck.
%

To test the communication between the GRACe server and the visual editor we can model
the API calls between the client and the server as
two data types \mintinline{Haskell}{ClientRequest} and
\mintinline{Haskell}{ServerResponse}, defined as follows:
%
\begin{minted}{Haskell}
data ClientRequest =
    AskLibraries
  | SubmitProgram LibraryName ProgramRepresentation

data ServerResponse =
    Libraries   [Library]
  | Assignments [(VariableName, Value)]
  | Error503
\end{minted}

The specification needs to makes use of external knowledge about the system
being specified and tested.
%
The specific piece of knowledge required is what libraries the server has access
to.
%
The specification is written to be parametric in this information:

\begin{minted}{Haskell}
spec :: (ClientRequest :< t, ServerResponse :< t)
     => [Library] -> Spec t ()
spec allLibraries = do
  req <- get anyClientRequest
  case req of
    AskLibraries  -> send (is $ Libraries allLibraries)
    SubmitProgram libName progRep
                  -> send (validAssignments libName allLibraries progRep)
  spec allLibraries
\end{minted}
%stopzone
%stopzone is a vim hack, dont remove

We omit the definition of the predicate
\begin{minted}{Haskell}
validAssignments :: LibraryName -> [Library] -> ProgramRepresentation
                 -> Predicate ServerResponse
\end{minted}
in the interest of brevity.
%
Writing the predicates in this specifiation is not necessarily a simple task.
%
To describe the client we would need to define what a correct program representation is
and come up with a way to generate such a representation.

To sum up, SessionCheck provides a small DSL, implemented in Haskell,
for specifying communicating systems.
%
It benefits from the strong type system of Haskell, but also extends
the reach of the specification to a large class of communication
protocols, including cases when the ``other end'' of the communication
is not written in Haskell (as in the case of the GRACeFUL visual
editor).

\section{Property-based testing of GRACe programs}
\label{sec:GCMP}

We use the |GCMP| (GRACeFUL Concept Map Property) type to define properties of
GRACe components and programs to test.
%
With the help of QuickCheck generators we can generate GRACe programs with
random parameter values and then test whether a given |GCMP| property holds in all
cases.
%
We test this by compiling the program to a MiniZinc model, running the model through
a constraint solver, and checking whether the solution found by the solver
satisfies the specified property.

We can test whether a GRACe component has been implemented correctly
by defining |GCMP| properties that describe its expected behavior and checking whether
those properties hold for all generated cases.
%
The user defines |GCMP| properties in a syntax similar to that used to define |GCM|
components and programs.

The following example code defines |GCMP| properties for the |pump| component from
the CRUD component library shown in section~\ref{sec:architecture}.
\begin{minted}{Haskell}
prop_pump :: GCMP ()
prop_pump = do
  -- Generate arbitrary parameter
  k   <- forall (fmap abs QC.arbitrary)
  -- Pump with arbitrary parameter
  (iflow, oflow) <- liftGCM $ pump k
  
  -- These properties should hold for the pump
  property "Inflow within capacity" $
    portVal iflow .<= lit k
  property "Outflow equal to inflow" $
    portVal oflow === portVal iflow
\end{minted}

We can test these properties using our testing framework. If they hold for all
generated test cases (currently set to 100) we get the following output:
\begin{verbatim}
Testing Pump...
+++++ Test passed! +++++
\end{verbatim}

If the properties do not always hold, the output will show the first failing
test case.
For example, suppose there is an error in the implementation of the pump such
that the outflow is not always equal to the inflow. Then the second property
should fail for some test cases, and the following output will appear, showing
that in the first failing test case the first property held but the second one
did not:
\begin{verbatim}
Testing Pump...
Failing test case: 
("prop_0 Inflow within capacity",True)
("prop_1 Outflow equal to inflow",False)
----- Test failed! -----
\end{verbatim}

\todo[inline]{Add concluding sentence here}

\section{Related Work}

This section presents a brief overview of related work on the main topics in this
document: Typed Values and SessionCheck. For related work on property-based
testing we refer to the original paper about QuickCheck~\cite{QuickCheck}.

\subsection{Typed Values}

Our implementation of Typed Values are related to the |Typeable| and |Dynamic|
libraries in Haskell~\cite{DataDynamic}, as mentioned before in
Section~\ref{sec:verification}. These libraries also offer the possibility to
hide the type of a value and to go back and forth from the untyped world. The
main difference is that our implementation is able to \emph{annotate} a type
representation, using the |Tag| constructor. We need this functionality to add
meta-data to a type representation of |GCM| parameters, of which we have showed an
example in Section~\ref{sec:intro}. The implementation of |Typeable| and
|Dynamic| is unfortunately closed, which means it is not possible to add a
|Tag|-like construct.


\subsection{SessionCheck}

This subsection describes research related to SessionCheck and how we
may incorporate some of the ideas present in the literature in future
work.

\paragraph{Mocking}

Mocking refers to the practice of simulating the behaviour of the
environment in order to exercise the functionality of a system under
test.
%
As an example of a mockup, consider testing the functionality of a software
component, which we will call |dashboard|, in a vehicle computer which is
meant to read the speed of a vehicle and update the dashboard display
appropriately.
%
The computer has a simple interface consisting of two functions,
|readSpeed| and |updateDisplay|.
%
A mockup designed to test the |dashboard| component would consist of a sequence
of expected calls to |readSpeed| and |updateDisplay| as well as their
respective arguments and return values.
%
In a notation similar to that of Svenningsson et al. \cite{HughesMocking}
a mockup which expects the |readSpeed| and |updateDisplay| functions to be
called sequentially may look like the following:
%
\begin{minted}[escapeinside=++,mathescape=true]{Haskell}
    readSpeed() |-> 5.833 . updateDisplay(speed, 21) |-> () . +$\varepsilon$+
\end{minted}
%
This mockup specifies that the call to |readSpeed| will return |5.833| and that
the subsequent call to |updateDisplay| will be called with the arguments
|speed| and |21|.
%
In this case the speed returned by |readSpeed| is in m/s and the speed indicated
on the display is meant to be in km/h.
%
Previous work on frameworks for mocking for testing communicating parties
in two-party and multi-party protocols by Svenningsson et al. \cite{HughesMocking}
as well as the GoogleMock \cite{GoogleMock} and EasyMock \cite{EasyMock} tools
for C++ and Java respectively focus on mocking individual components.
%
SessionCheck improves on the state of the art in mocking by introducing
both the possibility of checking consistency of specifications as well as
mocking both parties of a two-party protocol using a single specification.
%

In the context of GRACeFUL, mocking is useful for testing a single
layer of the software stack in isolation.
%
Specifically, it can be used to test the GRACe server separately from
the visual editor front-end.

\paragraph{Contracts, Chaperone Contracts, and Monitors}
%
Contracts \cite{Contracts} are a way of extending functions to provide runtime
monitoring of pre- and post-conditions and assigning blame to code which
violates these conditions.
%
In their implementation of typed contracts Hinze et al. \cite{ContractsHinze}
treat contracts as refinements of ordinary Haskell types.
%
As an example consider the partial |head| function which takes a list and
returns the first element:
%
\begin{minted}{haskell}
  head :: [a] -> a
  head (x:xs) = x
\end{minted}
%
In the scheme of Hinze et al.\ a contract of |head| which specifies that |head|
may only be called on a non-empty list is written as:
%
\begin{minted}{haskell}
  headContract :: Contract ([a] -> a)
  headContract = prop (\xs -> not (null xs))  ->>  true
\end{minted}
%
Here |prop :: (a -> Bool) -> Contract a| takes a predicate and lifts
it to a contract, |true| is the contract which is always satisfied,
equivalent to |prop (const True)|, and the infix combinator |(->>)|
forms a contract for functions.

%
Finally, associating |head| with its contract |headContract| is done
using the function |assert :: Contract a -> a -> a|:
%
\begin{minted}{haskell}
  headWithContract :: [a] -> [a]
  headWithContract = assert headContract head
\end{minted}
%
When a programmer uses the new |headWithContract| function the input is
dynamically checked and an error is reported in case the contract is violated,
that is to say when |headWithContract| is called on the empty list.
%
Crucially, the programmer can also specify location information for each call to
|headWithContract|, which will extend contract violations errors with specific
information about which call to |headWithContract| failed.

Melgratti and Padovani \cite{ChaperoneContracts} introduce ``Chaperone
Contracts'', as a method for specifying higher-order two-party
protocols. (Higher-order here means protocols which can transmit
protocol endpoints over the network.)
%
While this work is similar to SessionCheck it does not address the problem
of mocking protocol end points.
%
Furthermore, while the interface for contracts is very similar to ours,
providing primitives similar to our |send| and |get|, the interface is not
monadic.
%
Rather, specifications need to be explicitly sequenced using the
|(@@) :: Spec -> Spec -> Spec| combinator.
%
As a result of this, dependent contracts, where the constraints in |send| and
|get| depend on previous sent and received values, are specified using
special |send_d :: (a -> Bool) -> (a -> Spec) -> Spec| and
|get_d :: (a -> Bool) -> (a -> Spec) -> Spec| combinators.
%
This introduces additional syntactic noise by making dependency more
explicit than it already is.

One important benefit of Melgratti and Padovani's work over ours is
their ability to write higher order specifications, where protocol
end-points (including associated specifications), may be transmitted
on the communication channels.
%
We believe that modest extensions to SessionCheck would allow us to
use our specifications as contracts in a way similar to Melgratti and
Padovani.
%
Doing this would effectively provide a more convenient (monadic)
language for specifying contracts for the subset of protocols which
are first order.
%

\paragraph{The Scribble Specification Language}
%
The Scribble specification language \cite{Scribble} is a stand alone language
which permits specification of multi-party protocols.
%
Scribble specifications can be used to derive monitors which monitor communicating
parties to find protocol violations, and to derive skeleton code for implementing
the protocol in the Java language \cite{Java}.
%
Scribble also features an analog of the |dual| operation, |project|, which turns a
global specification into a local one.
%
Both |dual| and |project| have their origins in the literature on session types
\cite{HondaSessionTypes, WadlerSessionTypes}.

Our work differs significantly from Scribble.
%
SessionCheck is focused on testing and simulating protocols, while the language
leverages as much of the Haskell host language as possible, making the implementation
simple and succinct.
%
The SessionCheck language being embedded means generating skeleton code from a
specification is more difficult.
%
However, we have techniques in mind for a version of SessionCheck which can handle
both testing, use as a monitor, and generating skeleton code, bringing SessionCheck
up to speed with Scribble.
%

\section{Conclusion}

The GRACeFUL testing and verification framework is based on three
parts: declarative programming with strong types (in Haskell),
property-based testing in general (using QuickCheck), and the
SessionCheck tool for testing communicating systems in particular.
%
The strong type system of Haskell and the property-based testing tool
QuickCheck are off-the-shelf techniques developed by others but
adapted for GRACeFUL by WP4.
%
The main new contributions were Typed Values (described in
Section~\ref{sec:verification}), SessionCheck (described in
Section~\ref{sec:SessionCheck}), and property-based testing of GRACe programs 
(described in Section~\ref{sec:GCMP}).
%
% The full source code is available on github.

\bibliographystyle{plain}

\bibliography{main}

\end{document}

From Y2 review: ``We suggest that deliverables consisting of software
products also contain a written document that includes motivations,
use cases, explanations, user’s manuals, and informal semantics (if
possible).''

Note that D4.4 and D2.5 are both deliverables of type

  "DEM: Demonstrator, Pilot, Plans",

which is not described in detail in the H2020 documentation.
