\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[unicode=true]{hyperref}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Patrik Jansson et al.},
            pdftitle={GRACeFUL D4.4: Testing and verification framework},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

%% Cezar
\usepackage[margin=1.60in]{geometry}
\usepackage[verbose]{wrapfig}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{rotating}
\usepackage{lscape}
\usepackage{float}
\usepackage{geometry}
\usepackage{framed}
\usepackage{xspace}
\usepackage{acronym}
\usepackage[square,numbers]{natbib}

%% Max
\usepackage{minted}
\usepackage{todonotes}

%% Alex
\newminted{haskell}{fontsize=\normalsize,xleftmargin=2mm,mathescape,linenos}
\newcommand{\haskell}[1]{\mintinline{haskell}|#1|}
\DefineShortVerb{\|}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\definecolor{GRACeFULblue}{rgb}{0.20,0.60,0.86}

\newcommand{\grace}{GRACeFUL\xspace}
\acrodef{GCM}{\grace Concept Map}
\acrodef{GMB}{Group Model Building}
\acrodef{DSL}{Domain Specific Language}
\acrodef{CFP}{Constraint Functional Program}
\acrodef{RAT}{Rapid Assessment Tool}
\acrodef{CRUD}{Climate Resilient Urban Design}
\acrodef{CLD}{Causal Loop Diagram}
\acrodef{JSON}{JavaScript Object Notation}
\acrodef{CP}{Constraint Program}
\hyphenation{GRACeFUL}

\author{}
\date{}

\begin{document}

\begin{center}
\includegraphics[width=5cm]{../coverpage/GRACeFULlogo.png}

\textcolor{GRACeFULblue}{Global systems Rapid Assessment tools\\
through Constraint FUnctional Languages}

\vspace{1cm}

FETPROACT-1-2014 Grant Nº 640954

\end{center}

\begin{framed}
\begin{center}
\Large
D4.4: Testing and verification framework\\[1ex]

\large
D4.4 Testing and verification framework for RATs\\
with applications to the CRUD case study\\[1ex]

\end{center}
\end{framed}

\vspace{1cm}

\noindent
\begin{tabular}{@{}ll@{}}
  Lead Participant:       & Chalmers (WP leader: P. Jansson)
\\Dissemination Level:    & PU
\\Document Version:       & Draft
\\Date of Submission:     & 2018-0?-??
\\Due Date of Delivery:   & 2018-01-31
\end{tabular}

Authors: Maximilian Algehed, Sólrún Einarsdóttir, Alex Gerdes, and
Patrik Jansson.

\begin{abstract}

This fourth deliverable (D4.4) of work package 4 presents a framework for
testing and verifying communicating systems.
%
The work leading up to this deliverable is within Task 4.5 ``Build a
testing and verification framework for RATs'' and the full source code
of the implementation is available on GitHub.

\end{abstract}
\newpage

\section{Introduction}

\input{intro}

\section{Verification through types and tests}

\subsection{Strong types}
\todo{Alex: type systems as another testing/verification technique we make use of. TypedValues}

\subsection{Property-based testing}
\todo{Alex: introduce property based testing: [before Jan]}
\input{intro-property-based-testing}

\section{Testing Communicating Systems}
%
SessionCheck \cite{SessionCheck} is a tool developed in WP4 to test distributed systems like
the GRACeFUL editor.
%
The tool is focused on the communication protocols used between the components.
%
In the case of the GRACeFUL editor the protocol would be the REST API described in deliverable D4.3. %\cite{D4.3}
%
But, as the tool can do more than that, we here give a mini-tutorial
of how to use SessionCheck in general.

Typical testing of distributed systems is done by maintaining a database consisting of hundreds
or thousands of test-cases, each specifying the behaviour of one party in the protocol with
respect to a specific exchange of messages, a trace.
%
This approach is not ideal, as each test case is an artifact on its own which needs to be kept
in sync with the rest of the software.
%
SessionCheck relieves developers of the duty of maintaining hundreds of software
artifacts, replacing them with only three: the client, the server, and the SessionCheck specification.

To see the SessionCheck specfication language in action, consider a
simple protocol between a server and a client which requires the
client to transmit two positive integers and receive back from the
server their sum.
%
In SessionCheck, this specification would be written as follows:
%

\begin{minted}{Haskell}
  protocol :: Spec Int Int
  protocol = do
    a <- send posInt
    b <- send posInt
    get (is (a + b))
\end{minted}

%
SessionCheck specifications are written from the point of view of a particular party, in this case the client.
%
We may as well have written the same specification from the point of view of the server,
in which case it would look like this:
%

\begin{minted}{Haskell}
  protocol' :: Spec Int Int
  protocol' = do
    a <- get posInt
    b <- get posInt
    send (is (a + b))
  \end{minted}

%
It is no coincidence that the two specifications are very similar, and SessionCheck can work equally well with
both, as we will see shortly.

\begin{figure}[tbp]
  \begin{minted}{Haskell}
    data Spec t a   -- SessionCheck spec. for channel type t

    send    ::  a :< t =>  Predicate a ->       Spec t a
    get     ::  a :< t =>  Predicate a ->       Spec t a
    stop    ::                                  Spec t a
    fail    ::  String ->                       Spec t a
    return  ::  a ->                            Spec t a
    (>>=)   ::  Spec t a -> (a -> Spec t b) ->  Spec t b

    -- Derived combinators
    choose  :: (Eq a, a :< t) =>  [a] ->       Spec t a
    branch  :: (Eq a, a :< t) =>  [a] ->       Spec t a
  \end{minted}
  \caption{\label{fig:SessionCheck:language} The SessionCheck language}
\end{figure}
%
The SessionCheck specification language is a domain specific language embedded in the Haskell \cite{Haskell}
programming language.
%
Being an embedded language means that the language primitives in SessionCheck are
implemented as Haskell data types and functions.
%
The language primitives in SessionCheck can be seen in Figure \ref{fig:SessionCheck:language}.
%
The type argument \mintinline{Haskell}{t} in the type \mintinline{Haskell}{Spec t a} denotes the type of messages
being delivered on the channel on which the system under test is communicating
with SessionCheck.
%
The \mintinline{Haskell}{send} and \mintinline{Haskell}{get} primitives represent obligations for the respective party to send a message
which is compliant with the given \mintinline{Haskell}{Predicate}, more on this soon.
%
The type constraint \mintinline{Haskell}{a :< t} (for \mintinline{Haskell}{send} and
\mintinline{Haskell}{get}) denotes a subtyping relation between \mintinline{Haskell}{a} and
\mintinline{Haskell}{t}.
%
That is, any value of type \mintinline{Haskell}{a} can be transformed into value of type \mintinline{Haskell}{t}, and it may be
possible to transform a value of type \mintinline{Haskell}{t} into value of type \mintinline{Haskell}{a}.
%

Included in the interface are also the \mintinline{Haskell}{stop} and \mintinline{Haskell}{fail} functions.
%
The \mintinline{Haskell}{stop} primitive specifies that the protocol session is terminated.
%TODO: successfully terminated?, difference from return?
Unlike \mintinline{Haskell}{send}, \mintinline{Haskell}{get}, and \mintinline{Haskell}{stop}, the \mintinline{Haskell}{fail} primitive does not directly correspond to an action in the protocol.
%
Rather it allows the user to specify conditions, for when the system being tested by SessionCheck fails,
which are not directly coupled to constraints on messages.
%
The \mintinline{Haskell}{choose} and \mintinline{Haskell}{branch} primitives are not actually
primitive operations, rather they are derived from (implemented using)
the rest of the interface.
%
The specification \mintinline{Haskell}{choose xs} reads ``send one of the values in \mintinline{Haskell}{xs}'', while \mintinline{Haskell}{branch xs} reads ``get one
of the values in \mintinline{Haskell}{xs}''.

The primitives explained so far do not permit small specifications
(like \mintinline{Haskell}{send anyInt} and \mintinline{Haskell}{get anyBool}) to be composed to
form more complex specifications.
%
For this purpose SessionCheck also supports the standard \mintinline{Haskell}{Monad} interface~\cite{WadlerMonad}, which contains the
two primitive operations \mintinline{Haskell}{return} and \mintinline{Haskell}{(>>=)} (pronounced ``bind'').
%
The bind operator allows specifications to be composed by taking a specification, \mintinline{Haskell}{s}, and a function which
creates a specification from a value, \mintinline{Haskell}{f}, and composing them to form the specification \mintinline{Haskell}{s >>= f} which means
``first the protocol behaves like \mintinline{Haskell}{s}, then whatever value is produced at the end of \mintinline{Haskell}{s} is fed to \mintinline{Haskell}{f} to produce
a new specification to follow''.
%
As an example, consider the case where \mintinline{Haskell}{s = send anyInt} and \mintinline{Haskell}{f x = send (greaterThan x)}, here \mintinline{Haskell}{s >>= f} is
a specification which first requires the end-point to send an \mintinline{Haskell}{Int} and then to send another \mintinline{Haskell}{Int} which is greater
than the first one.
%
The \mintinline{Haskell}{do ...} notation in the above examples is syntactic sugar for successive uses of \mintinline{Haskell}{(>>=)} and lambda abstraction
\mintinline{Haskell}{\ x -> e}, where the expression \mintinline{Haskell}{\ x -> e} denotes a function where the variable \mintinline{Haskell}{x} is used to bind the input of
the function in the (output) expression \mintinline{Haskell}{e}.
%
When written using explicit \mintinline{Haskell}{(>>=)} the specification of \mintinline{Haskell}{protocol} could look like this:
%
\begin{minted}{haskell}
protocol :: Spec Int Int
protocol = send posInt >>= \ a -> send posInt >>= \ b -> get (is (a + b))
\end{minted}


%
Supporting the generic \mintinline{Haskell}{Monad} interface means that we get several useful combinators ``for free'', like
\mintinline{Haskell}{(>>) :: Spec t a -> Spec t b -> Spec t b} which sequences two independent specifications, and
\mintinline{Haskell}{forever :: Spec t a -> Spec t b} which repeats a specification indefinitely.
%
Finally, the \mintinline{Haskell}{return} function simply wraps a value in a specification.
%
It represents no obligation on either part of the communication protocol, but rather is part of the standard
monad interface.
%

% \begin{figure}
%   \begin{minted}{haskell}
%     echo = do
%       s <- send anyString
%       get (is s)
%   \end{minted}
%   \caption{\label{fig:SessionCheck:echo} The \mintinline{Haskell}{echo} protocol}
% \end{figure}
% %
As a third example of a SessionCheck specification we can take the \mintinline{Haskell}{echo} protocol:
%
\begin{minted}{haskell}
  echo = do
    s <- send anyString
    get (is s)
\end{minted}
%
In this protocol the client sends a single string to the server which
replies with the same string.
%
We can use this specification to verify that either a client or a server implementation of
the protocol is correct.
%
For example, when testing a faulty server implementation SessionCheck will print the following:
%
\begin{verbatim}
Failed with:
Bad: get {is ""}

With trace:
Output {""}
InputViolates {is ""} "\n\r"
\end{verbatim}

To see the SessionCheck language in action we will briefly explore
using SessionCheck to specify a small book ordering service.
%
The idea of this protocol is that the client transmits a number of
books it wants to order to the server, followed by a
\mintinline{Haskell}{checkout} message.
%
The server then transmits back to the client the clients current
basket.
%
We hope that this small example is sufficient to see how SessionCheck
might be used to specify larger protocols.
%
We start by specifying the type of messages which may be transmitted
between the client and the server.
%
The client will transmit \mintinline{Haskell}{Request} messages and
the server will reply with \mintinline{Haskell}{Reply} messages.
%
In this simple example we get the ordinary Haskell types below.
%
\begin{minted}{Haskell}
  data Request  =  Order String | Checkout

  data Reply    =  Basket [String]
\end{minted}

The protocol contains a loop where the client orders books.
%
\begin{minted}{Haskell}
  loop :: Request :< t =>  [String] -> Spec t [String]
  loop books = do
    r <- anyRequest
    case r of
      Order book -> loop (book:books)
      Checkout   -> return books
\end{minted}
%
Having specified the loop we can put everything together into the final protocol.
%
\begin{minted}{Haskell}
  protocol :: (Request :< t, Reply :< t) =>  Spec t Reply
  protocol = do
    books <- loop []
    get (supersetOf books)
\end{minted}

So far we have only seen how we can specify and test one part of a protocol.
%
However, thanks to something called duality, a client specification gives rise
to a server specification without any effort.
%
The key idea of duality is that if a specification specifies one part
of a two-party protocol, then the same specfication with all instances
of \mintinline{Haskell}{send} replaced by \mintinline{Haskell}{get}
and vice-versa specifies the other.
%
In SessionCheck, duality is implemented as a function \mintinline{Haskell}{dual :: Spec t a -> Spec t a}.
%
The specification (not implementation) of \mintinline{Haskell}{dual} can be seen below.
%
\begin{minted}{Haskell}
  dual :: Spec t a   ->  Spec t a
  dual    (send p)    =  get p
  dual    (get p)     =  send p
  dual    stop        =  stop
  dual    (fail s)    =  fail s
  dual    (return a)  =  return a
  dual    (s >>= f)   =  dual s >>= dual . f
\end{minted}
%
To see duality in action consider the \mintinline{Haskell}{echo} protocol above.
%
When written using explicit \mintinline{Haskell}{(>>=)} the protocol looks like this
%
\begin{minted}{haskell}
  echo = send anyString >>= \ s -> get (is s)
\end{minted}
%
the \mintinline{Haskell}{dual} of which can be computed to
%
\begin{minted}{haskell}
  dual echo = get anyString >>= \ s -> send (is s)
\end{minted}
%
Which when written using the more convenient \mintinline{Haskell}{do} notation is simply
%
\begin{minted}{haskell}
  dual echo = do
    s <- get anyString
    send (is s)
\end{minted}
%
Which is clearly a specification of an \mintinline{Haskell}{echo} server.

To sum up, SessionCheck provides a small DSL, implemented in Haskell,
for specifying communicating systems.
%
It benefits from the strong type system of Haskell, but also extends
the reach of the specification to a large class of communication
protocols, including cases when the ``other end'' of the communication
is not written in Haskell (as in the case of the GRACeFUL visual
editor).

\section{Solver Testing}
\todo{Solrun+Maximilian: Testing solvers and backends: challenges and partial solutions}
\input{solver-testing}


\section{Property based testing of GRACe programs}

Maximilian: Tell the story about bugs fixed in the compiler?

\todo{Solrun: try out sessioncheck before Jan.}

\todo{Max: fill in more based on using Jan.}

\section{Related Work}

This section presents a brief overview of related work and provides accounts
of how SessionCheck relates to them as well as how we may incorporate some of
the ideas present in the literature in future work.

\paragraph{Mocking}

Mocking refers to the practice of creating software components specifically
in order to exercise the functionality of a system under test.
%
As an example of a mockup, consider testing the functionality of a software
component, which we will call |dashboard|, in a vehicle computer which is
meant to read the speed of a vehicle and update the dashboard display
appropriately.
%
The computer has a simple interface consisting of two functions,
|readSpeed| and |updateDisplay|.
%
A mockup designed to test the |dashboard| component would consist of a sequence
of expected calls to |readSpeed| and |updateDisplay| as well as their
respective arguments and return values.
%
In a notation similar to that of Svenningsson et al. \cite{HughesMocking}
a mockup which expects the |readSpeed| and |updateDisplay| functions to be
called sequentially may look like the following:
%
\begin{minted}{Haskell}
    readSpeed() |-> 5.833 fs updateDisplay(speed, 21) |-> () fs eps
\end{minted}
%
This mockup specifies that the call to |readSpeed| will return |5.833| and that
the subsequent call to |updateDisplay| will be called with the arguments
|speed| and |21|.
%
In this case the speed returned by |readSpeed| is in m/s and the speed indicated
on the display is meant to be in km/h.
%
Previous work on frameworks for mocking for testing communicating parties
in two-party and multi-party protocols by Svenningsson et al. \cite{HughesMocking}
as well as the GoogleMock \cite{GoogleMock} and EasyMock \cite{EasyMock} tools
for C++ and Java respectively focus on mocking individual components.
%
SessionCheck improves on the state of the art in mocking by introducing
both the possibility of checking consistency of specifications as well as
mocking both parties of a two-party protocol using a single specification.
%

In the context of GRACeFUL, mocking is useful for testing a single
layer of the software stack in isolation.
%
Specifically, it can be used to test the GRACe server separately from
the visual editor front-end.

\paragraph{Contracts, Chaperone Contracts, and Monitors}
%
Contracts \cite{Contracts} are a way of extending functions to provide runtime
monitoring of pre- and post-conditions and assigning blame to code which
violates these conditions.
%
In their implementation of typed contracts Hinze et al. \cite{ContractsHinze}
treat contracts as refinements of ordinary Haskell types.
%
As an example consider the partial |head| function which takes a list and
returns the first element:
%
\begin{minted}{haskell}
  head :: [a] -> a
  head (x:xs) = x
\end{minted}
%
In the scheme of Hinze et al.\ a contract of |head| which specifies that |head|
may only be called on a non-empty list is written as:
%
\begin{minted}{haskell}
  headContract :: Contract ([a] -> a)
  headContract = prop (\xs -> not (null xs))  ->>  true
\end{minted}
%
Here |prop :: (a -> Bool) -> Contract a| takes a predicate and lifts
it to a contract, |true| is the contract which is always satisfied,
equivalent to |prop (const True)|, and the infix combinator |(->>)|
forms a contract for functions.

%
Finally, associating |head| with its contract |headContract| is done
using the function |assert :: Contract a -> a -> a|:
%
\begin{minted}{haskell}
  headWithContract :: [a] -> [a]
  headWithContract = assert headContract head
\end{minted}
%
When a programmer uses the new |headWithContract| function the input is
dynamically checked and an error is reported in case the contract is violated,
that is to say when |headWithContract| is called on the empty list.
%
Crucially, the programmer can also specify location information for each call to
|headWithContract|, which will extend contract violations errors with specific
information about which call to |headWithContract| failed.

Melgratti and Padovani \cite{ChaperoneContracts} introduce ``Chaperone
Contracts'', as a method for specifying higher-order two-party
protocols. (Higher-order here means protocols which can transmit
protocol endpoints over the network.)
%
While this work is similar to SessionCheck it does not address the problem
of mocking protocol end points.
%
Furthermore, while the interface for contracts is very similar to ours,
providing primitives similar to our |send| and |get|, the interface is not
monadic.
%
Rather, specifications need to be explicitly sequenced using the
|(@@) :: Spec -> Spec -> Spec| combinator.
%
As a result of this, dependent contracts, where the constraints in |send| and
|get| depend on previous sent and received values, are specified using
special |send_d :: (a -> Bool) -> (a -> Spec) -> Spec| and
|get_d :: (a -> Bool) -> (a -> Spec) -> Spec| combinators.
%
This introduces additional syntactic noise by making dependency more
explicit than it already is.

One important benefit of Melgratti and Padovani's work over ours is
their ability to write higher order specifications, where protocol
end-points (including associated specifications), may be transmitted
on the communication channels.
%
We believe that modest extensions to SessionCheck would allow us to
use our specifications as contracts in a way similar to Melgratti and
Padovani.
%
Doing this would effectively provide a more convenient (monadic)
language for specifying contracts for the subset of protocols which
are first order.
%

\paragraph{The Scribble Specification Language}
%
The Scribble specification language \cite{Scribble} is a stand alone language
which permits specification of multi-party protocols.
%
Scribble specifications can be used to derive monitors which monitor communicating
parties to find protocol violations, and to derive skeleton code for implementing
the protocol in the Java language \cite{Java}.
%
Scribble also features an analog of the |dual| operation, |project|, which turns a
global specification into a local one.
%
Both |dual| and |project| have their origins in the literature on session types
\cite{HondaSessionTypes, WadlerSessionTypes}.

Our work differs significantly from Scribble.
%
SessionCheck is focused on testing and simulating protocols, while the language
leverages as much of the Haskell host language as possible, making the implementation
simple and succinct.
%
The SessionCheck language being embedded means generating skeleton code from a
specification is more difficult.
%
However, we have techniques in mind for a version of SessionCheck which can handle
both testing, use as a monitor, and generating skeleton code, bringing SessionCheck
up to speed with Scribble.
%

\section{Conclusion}

\bibliographystyle{plain}

\bibliography{main}

\end{document}

From Y2 review: ``We suggest that deliverables consisting of software
products also contain a written document that includes motivations,
use cases, explanations, user’s manuals, and informal semantics (if
possible).''

Note that D4.4 and D2.5 are both deliverables of type

  "DEM: Demonstrator, Pilot, Plans",

which is not described in detail in the H2020 documentation.
